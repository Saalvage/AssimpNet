// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace AssimpNet.Unmanaged
{
    /// <summary>Helper structure to represent a texel in a ARGB8888 format</summary>
    /// <remarks>Used by aiTexture.</remarks>
    public unsafe partial class Texel : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal byte b;
            internal byte g;
            internal byte r;
            internal byte a;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.Texel> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.Texel>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.Texel managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.Texel managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Texel __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Texel(native.ToPointer(), skipVTables);
        }

        internal static Texel __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Texel)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Texel __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Texel(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Texel(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Texel(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte B
        {
            get
            {
                return ((__Internal*)__Instance)->b;
            }

            set
            {
                ((__Internal*)__Instance)->b = value;
            }
        }

        public byte G
        {
            get
            {
                return ((__Internal*)__Instance)->g;
            }

            set
            {
                ((__Internal*)__Instance)->g = value;
            }
        }

        public byte R
        {
            get
            {
                return ((__Internal*)__Instance)->r;
            }

            set
            {
                ((__Internal*)__Instance)->r = value;
            }
        }

        public byte A
        {
            get
            {
                return ((__Internal*)__Instance)->a;
            }

            set
            {
                ((__Internal*)__Instance)->a = value;
            }
        }
    }

    /// <summary>Helper structure to describe an embedded texture</summary>
    /// <remarks>
    /// <para>Normally textures are contained in external files but some file formats embed</para>
    /// <para>them directly in the model file. There are two types of embedded textures:</para>
    /// <para>1. Uncompressed textures. The color data is given in an uncompressed format.</para>
    /// <para>2. Compressed textures stored in a file format like png or jpg. The raw file</para>
    /// <para>bytes are given so the application must utilize an image decoder (e.g. DevIL) to</para>
    /// <para>get access to the actual color data.</para>
    /// <para>Embedded textures are referenced from materials using strings like &quot;*0&quot;, &quot;*1&quot;, etc.</para>
    /// <para>as the texture paths (a single asterisk character followed by the</para>
    /// <para>zero-based index of the texture in the aiScene::mTextures array).</para>
    /// </remarks>
    public unsafe partial class Texture : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1064)]
        public partial struct __Internal
        {
            internal uint mWidth;
            internal uint mHeight;
            internal fixed sbyte achFormatHint[9];
            internal __IntPtr pcData;
            internal global::AssimpNet.Unmanaged.String.__Internal mFilename;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.Texture> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.Texture>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.Texture managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.Texture managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Texture __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Texture(native.ToPointer(), skipVTables);
        }

        internal static Texture __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Texture)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Texture __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Texture(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Texture(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Texture(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Width of the texture, in pixels</summary>
        /// <remarks>
        /// <para>If mHeight is zero the texture is compressed in a format</para>
        /// <para>like JPEG. In this case mWidth specifies the size of the</para>
        /// <para>memory area pcData is pointing to, in bytes.</para>
        /// </remarks>
        public uint MWidth
        {
            get
            {
                return ((__Internal*)__Instance)->mWidth;
            }

            set
            {
                ((__Internal*)__Instance)->mWidth = value;
            }
        }

        /// <summary>Height of the texture, in pixels</summary>
        /// <remarks>
        /// <para>If this value is zero, pcData points to an compressed texture</para>
        /// <para>in any format (e.g. JPEG).</para>
        /// </remarks>
        public uint MHeight
        {
            get
            {
                return ((__Internal*)__Instance)->mHeight;
            }

            set
            {
                ((__Internal*)__Instance)->mHeight = value;
            }
        }

        /// <summary>
        /// <para>A hint from the loader to make it easier for applications</para>
        /// <para>to determine the type of embedded textures.</para>
        /// </summary>
        /// <remarks>
        /// <para>If mHeight != 0 this member is show how data is packed. Hint will consist of</para>
        /// <para>two parts: channel order and channel bitness (count of the bits for every</para>
        /// <para>color channel). For simple parsing by the viewer it's better to not omit</para>
        /// <para>absent color channel and just use 0 for bitness. For example:</para>
        /// <para>1. Image contain RGBA and 8 bit per channel, achFormatHint == &quot;rgba8888&quot;;</para>
        /// <para>2. Image contain ARGB and 8 bit per channel, achFormatHint == &quot;argb8888&quot;;</para>
        /// <para>3. Image contain RGB and 5 bit for R and B channels and 6 bit for G channel, achFormatHint == &quot;rgba5650&quot;;</para>
        /// <para>4. One color image with B channel and 1 bit for it, achFormatHint == &quot;rgba0010&quot;;</para>
        /// <para>If mHeight == 0 then achFormatHint is set set to '\0\0\0\0' if the loader has no additional</para>
        /// <para>information about the texture file format used OR the</para>
        /// <para>file extension of the format without a trailing dot. If there</para>
        /// <para>are multiple file extensions for a format, the shortest</para>
        /// <para>extension is chosen (JPEG maps to 'jpg', not to 'jpeg').</para>
        /// <para>E.g. 'dds\0', 'pcx\0', 'jpg\0'.  All characters are lower-case.</para>
        /// <para>The fourth character will always be '\0'.</para>
        /// </remarks>
        public sbyte[] AchFormatHint
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->achFormatHint, 9);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 9; i++)
                        ((__Internal*)__Instance)->achFormatHint[i] = value[i];
                }
            }
        }

        /// <summary>Data of the texture.</summary>
        /// <remarks>
        /// <para>Points to an array of mWidth * mHeight aiTexel's.</para>
        /// <para>The format of the texture data is always ARGB8888 to</para>
        /// <para>make the implementation for user of the library as easy</para>
        /// <para>as possible. If mHeight = 0 this is a pointer to a memory</para>
        /// <para>buffer of size mWidth containing the compressed texture</para>
        /// <para>data. Good luck, have fun!</para>
        /// </remarks>
        public global::AssimpNet.Unmanaged.Texel PcData
        {
            get
            {
                var __result0 = global::AssimpNet.Unmanaged.Texel.__GetOrCreateInstance(((__Internal*)__Instance)->pcData, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->pcData = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>Texture original filename</summary>
        /// <remarks>Used to get the texture reference</remarks>
        public global::AssimpNet.Unmanaged.String MFilename
        {
            get
            {
                return global::AssimpNet.Unmanaged.String.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->mFilename));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->mFilename = *(global::AssimpNet.Unmanaged.String.__Internal*) value.__Instance;
            }
        }
    }
}
