// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace AssimpNet.Unmanaged
{
    public enum AnimInterpolation
    {
        AnimInterpolationStep = 0,
        AnimInterpolationLinear = 1,
        AnimInterpolationSphericalLinear = 2,
        AnimInterpolationCubicSpline = 3,
        AiAnimInterpolationForce32Bit = 2147483647
    }

    /// <summary>
    /// <para>Defines how an animation channel behaves outside the defined time</para>
    /// <para>range. This corresponds to aiNodeAnim::mPreState and</para>
    /// <para>aiNodeAnim::mPostState.</para>
    /// </summary>
    public enum AnimBehaviour
    {
        /// <summary>The value from the default node transformation is taken</summary>
        AnimBehaviourDEFAULT = 0,
        /// <summary>The nearest key value is used without interpolation</summary>
        AnimBehaviourCONSTANT = 1,
        /// <summary>
        /// <para>The value of the nearest two keys is linearly</para>
        /// <para>extrapolated for the current time value.</para>
        /// </summary>
        AnimBehaviourLINEAR = 2,
        /// <summary>The animation is repeated.</summary>
        /// <remarks>
        /// <para>If the animation key go from n to m and the current</para>
        /// <para>time is t, use the value at (t-n) % (|m-n|).</para>
        /// </remarks>
        AnimBehaviourREPEAT = 3,
        AiAnimBehaviourForce32Bit = 2147483647
    }

    /// <summary>A time-value pair specifying a certain 3D vector for the given time.</summary>
    public unsafe partial class VectorKey : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal double mTime;
            internal global::System.Numerics.Vector3 mValue;
            internal global::AssimpNet.Unmanaged.AnimInterpolation mInterpolation;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.VectorKey> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.VectorKey>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.VectorKey managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.VectorKey managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VectorKey __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VectorKey(native.ToPointer(), skipVTables);
        }

        internal static VectorKey __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VectorKey)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VectorKey __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VectorKey(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VectorKey(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VectorKey(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The time of this key</summary>
        public double MTime
        {
            get
            {
                return ((__Internal*)__Instance)->mTime;
            }

            set
            {
                ((__Internal*)__Instance)->mTime = value;
            }
        }

        /// <summary>The value of this key</summary>
        public global::System.Numerics.Vector3 MValue
        {
            get
            {
                return ((__Internal*)__Instance)->mValue;
            }

            set
            {
                ((__Internal*)__Instance)->mValue = value;
            }
        }

        /// <summary>The interpolation setting of this key</summary>
        public global::AssimpNet.Unmanaged.AnimInterpolation MInterpolation
        {
            get
            {
                return ((__Internal*)__Instance)->mInterpolation;
            }

            set
            {
                ((__Internal*)__Instance)->mInterpolation = value;
            }
        }
    }

    /// <summary>
    /// <para>A time-value pair specifying a rotation for the given time.</para>
    /// <para>Rotations are expressed with quaternions.</para>
    /// </summary>
    public unsafe partial class QuatKey : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal double mTime;
            internal global::System.Numerics.Quaternion mValue;
            internal global::AssimpNet.Unmanaged.AnimInterpolation mInterpolation;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.QuatKey> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.QuatKey>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.QuatKey managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.QuatKey managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static QuatKey __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new QuatKey(native.ToPointer(), skipVTables);
        }

        internal static QuatKey __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (QuatKey)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static QuatKey __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new QuatKey(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private QuatKey(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected QuatKey(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The time of this key</summary>
        public double MTime
        {
            get
            {
                return ((__Internal*)__Instance)->mTime;
            }

            set
            {
                ((__Internal*)__Instance)->mTime = value;
            }
        }

        /// <summary>The value of this key</summary>
        public global::System.Numerics.Quaternion MValue
        {
            get
            {
                return ((__Internal*)__Instance)->mValue;
            }

            set
            {
                ((__Internal*)__Instance)->mValue = value;
            }
        }

        /// <summary>The interpolation setting of this key</summary>
        public global::AssimpNet.Unmanaged.AnimInterpolation MInterpolation
        {
            get
            {
                return ((__Internal*)__Instance)->mInterpolation;
            }

            set
            {
                ((__Internal*)__Instance)->mInterpolation = value;
            }
        }
    }

    /// <summary>Binds a anim-mesh to a specific point in time.</summary>
    public unsafe partial class MeshKey : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal double mTime;
            internal uint mValue;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.MeshKey> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.MeshKey>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.MeshKey managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.MeshKey managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static MeshKey __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new MeshKey(native.ToPointer(), skipVTables);
        }

        internal static MeshKey __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (MeshKey)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static MeshKey __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MeshKey(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MeshKey(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected MeshKey(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The time of this key</summary>
        public double MTime
        {
            get
            {
                return ((__Internal*)__Instance)->mTime;
            }

            set
            {
                ((__Internal*)__Instance)->mTime = value;
            }
        }

        /// <summary>
        /// <para>Index into the aiMesh::mAnimMeshes array of the</para>
        /// <para>mesh corresponding to the #aiMeshAnim hosting this</para>
        /// <para>key frame. The referenced anim mesh is evaluated</para>
        /// <para>according to the rules defined in the docs for #aiAnimMesh.</para>
        /// </summary>
        public uint MValue
        {
            get
            {
                return ((__Internal*)__Instance)->mValue;
            }

            set
            {
                ((__Internal*)__Instance)->mValue = value;
            }
        }
    }

    /// <summary>Binds a morph anim mesh to a specific point in time.</summary>
    public unsafe partial class MeshMorphKey : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal double mTime;
            internal __IntPtr mValues;
            internal __IntPtr mWeights;
            internal uint mNumValuesAndWeights;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.MeshMorphKey> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.MeshMorphKey>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.MeshMorphKey managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.MeshMorphKey managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static MeshMorphKey __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new MeshMorphKey(native.ToPointer(), skipVTables);
        }

        internal static MeshMorphKey __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (MeshMorphKey)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static MeshMorphKey __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MeshMorphKey(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MeshMorphKey(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected MeshMorphKey(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The time of this key</summary>
        public double MTime
        {
            get
            {
                return ((__Internal*)__Instance)->mTime;
            }

            set
            {
                ((__Internal*)__Instance)->mTime = value;
            }
        }

        /// <summary>
        /// <para>The values and weights at the time of this key</para>
        /// <para>- mValues: index of attachment mesh to apply weight at the same position in mWeights</para>
        /// <para>- mWeights: weight to apply to the blend shape index at the same position in mValues</para>
        /// </summary>
        public uint* MValues
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->mValues;
            }

            set
            {
                ((__Internal*)__Instance)->mValues = (__IntPtr) value;
            }
        }

        public double* MWeights
        {
            get
            {
                return (double*) ((__Internal*)__Instance)->mWeights;
            }

            set
            {
                ((__Internal*)__Instance)->mWeights = (__IntPtr) value;
            }
        }

        /// <summary>The number of values and weights</summary>
        public uint MNumValuesAndWeights
        {
            get
            {
                return ((__Internal*)__Instance)->mNumValuesAndWeights;
            }

            set
            {
                ((__Internal*)__Instance)->mNumValuesAndWeights = value;
            }
        }
    }

    /// <summary>
    /// <para>Describes the animation of a single node. The name specifies the</para>
    /// <para>bone/node which is affected by this animation channel. The keyframes</para>
    /// <para>are given in three separate series of values, one each for position,</para>
    /// <para>rotation and scaling. The transformation matrix computed from these</para>
    /// <para>values replaces the node's original transformation matrix at a</para>
    /// <para>specific time.</para>
    /// <para>This means all keys are absolute and not relative to the bone default pose.</para>
    /// <para>The order in which the transformations are applied is</para>
    /// <para>- as usual - scaling, rotation, translation.</para>
    /// </summary>
    /// <remarks>
    /// <para>All keys are returned in their correct, chronological order.</para>
    /// <para>Duplicate keys don't pass the validation step. Most likely there</para>
    /// <para>will be no negative time values, but they are not forbidden also ( so</para>
    /// <para>implementations need to cope with them! )</para>
    /// </remarks>
    public unsafe partial class NodeAnim : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1080)]
        public partial struct __Internal
        {
            internal global::AssimpNet.Unmanaged.String.__Internal mNodeName;
            internal uint mNumPositionKeys;
            internal __IntPtr mPositionKeys;
            internal uint mNumRotationKeys;
            internal __IntPtr mRotationKeys;
            internal uint mNumScalingKeys;
            internal __IntPtr mScalingKeys;
            internal global::AssimpNet.Unmanaged.AnimBehaviour mPreState;
            internal global::AssimpNet.Unmanaged.AnimBehaviour mPostState;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.NodeAnim> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.NodeAnim>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.NodeAnim managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.NodeAnim managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static NodeAnim __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new NodeAnim(native.ToPointer(), skipVTables);
        }

        internal static NodeAnim __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (NodeAnim)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static NodeAnim __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new NodeAnim(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private NodeAnim(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected NodeAnim(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>The name of the node affected by this animation. The node</para>
        /// <para>must exist and it must be unique.</para>
        /// </summary>
        public global::AssimpNet.Unmanaged.String MNodeName
        {
            get
            {
                return global::AssimpNet.Unmanaged.String.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->mNodeName));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->mNodeName = *(global::AssimpNet.Unmanaged.String.__Internal*) value.__Instance;
            }
        }

        /// <summary>The number of position keys</summary>
        public uint MNumPositionKeys
        {
            get
            {
                return ((__Internal*)__Instance)->mNumPositionKeys;
            }

            set
            {
                ((__Internal*)__Instance)->mNumPositionKeys = value;
            }
        }

        /// <summary>
        /// <para>The position keys of this animation channel. Positions are</para>
        /// <para>specified as 3D vector. The array is mNumPositionKeys in size.</para>
        /// </summary>
        /// <remarks>
        /// <para>If there are position keys, there will also be at least one</para>
        /// <para>scaling and one rotation key.</para>
        /// </remarks>
        public global::AssimpNet.Unmanaged.VectorKey MPositionKeys
        {
            get
            {
                var __result0 = global::AssimpNet.Unmanaged.VectorKey.__GetOrCreateInstance(((__Internal*)__Instance)->mPositionKeys, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->mPositionKeys = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>The number of rotation keys</summary>
        public uint MNumRotationKeys
        {
            get
            {
                return ((__Internal*)__Instance)->mNumRotationKeys;
            }

            set
            {
                ((__Internal*)__Instance)->mNumRotationKeys = value;
            }
        }

        /// <summary>
        /// <para>The rotation keys of this animation channel. Rotations are</para>
        /// <para>given as quaternions,  which are 4D vectors. The array is</para>
        /// <para>mNumRotationKeys in size.</para>
        /// </summary>
        /// <remarks>
        /// <para>If there are rotation keys, there will also be at least one</para>
        /// <para>scaling and one position key.</para>
        /// </remarks>
        public global::AssimpNet.Unmanaged.QuatKey MRotationKeys
        {
            get
            {
                var __result0 = global::AssimpNet.Unmanaged.QuatKey.__GetOrCreateInstance(((__Internal*)__Instance)->mRotationKeys, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->mRotationKeys = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>The number of scaling keys</summary>
        public uint MNumScalingKeys
        {
            get
            {
                return ((__Internal*)__Instance)->mNumScalingKeys;
            }

            set
            {
                ((__Internal*)__Instance)->mNumScalingKeys = value;
            }
        }

        /// <summary>
        /// <para>The scaling keys of this animation channel. Scalings are</para>
        /// <para>specified as 3D vector. The array is mNumScalingKeys in size.</para>
        /// </summary>
        /// <remarks>
        /// <para>If there are scaling keys, there will also be at least one</para>
        /// <para>position and one rotation key.</para>
        /// </remarks>
        public global::AssimpNet.Unmanaged.VectorKey MScalingKeys
        {
            get
            {
                var __result0 = global::AssimpNet.Unmanaged.VectorKey.__GetOrCreateInstance(((__Internal*)__Instance)->mScalingKeys, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->mScalingKeys = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>
        /// <para>Defines how the animation behaves before the first</para>
        /// <para>key is encountered.</para>
        /// </summary>
        /// <remarks>
        /// <para>The default value is aiAnimBehaviour_DEFAULT (the original</para>
        /// <para>transformation matrix of the affected node is used).</para>
        /// </remarks>
        public global::AssimpNet.Unmanaged.AnimBehaviour MPreState
        {
            get
            {
                return ((__Internal*)__Instance)->mPreState;
            }

            set
            {
                ((__Internal*)__Instance)->mPreState = value;
            }
        }

        /// <summary>
        /// <para>Defines how the animation behaves after the last</para>
        /// <para>key was processed.</para>
        /// </summary>
        /// <remarks>
        /// <para>The default value is aiAnimBehaviour_DEFAULT (the original</para>
        /// <para>transformation matrix of the affected node is taken).</para>
        /// </remarks>
        public global::AssimpNet.Unmanaged.AnimBehaviour MPostState
        {
            get
            {
                return ((__Internal*)__Instance)->mPostState;
            }

            set
            {
                ((__Internal*)__Instance)->mPostState = value;
            }
        }
    }

    /// <summary>
    /// <para>Describes vertex-based animations for a single mesh or a group of</para>
    /// <para>meshes. Meshes carry the animation data for each frame in their</para>
    /// <para>aiMesh::mAnimMeshes array. The purpose of aiMeshAnim is to</para>
    /// <para>define keyframes linking each mesh attachment to a particular</para>
    /// <para>point in time.</para>
    /// </summary>
    public unsafe partial class MeshAnim : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1040)]
        public partial struct __Internal
        {
            internal global::AssimpNet.Unmanaged.String.__Internal mName;
            internal uint mNumKeys;
            internal __IntPtr mKeys;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.MeshAnim> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.MeshAnim>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.MeshAnim managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.MeshAnim managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static MeshAnim __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new MeshAnim(native.ToPointer(), skipVTables);
        }

        internal static MeshAnim __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (MeshAnim)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static MeshAnim __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MeshAnim(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MeshAnim(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected MeshAnim(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Name of the mesh to be animated. An empty string is not allowed,</para>
        /// <para>animated meshes need to be named (not necessarily uniquely,</para>
        /// <para>the name can basically serve as wild-card to select a group</para>
        /// <para>of meshes with similar animation setup)</para>
        /// </summary>
        public global::AssimpNet.Unmanaged.String MName
        {
            get
            {
                return global::AssimpNet.Unmanaged.String.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->mName));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->mName = *(global::AssimpNet.Unmanaged.String.__Internal*) value.__Instance;
            }
        }

        /// <summary>Size of the #mKeys array. Must be 1, at least.</summary>
        public uint MNumKeys
        {
            get
            {
                return ((__Internal*)__Instance)->mNumKeys;
            }

            set
            {
                ((__Internal*)__Instance)->mNumKeys = value;
            }
        }

        /// <summary>Key frames of the animation. May not be nullptr.</summary>
        public global::AssimpNet.Unmanaged.MeshKey MKeys
        {
            get
            {
                var __result0 = global::AssimpNet.Unmanaged.MeshKey.__GetOrCreateInstance(((__Internal*)__Instance)->mKeys, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->mKeys = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>Describes a morphing animation of a given mesh.</summary>
    public unsafe partial class MeshMorphAnim : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1040)]
        public partial struct __Internal
        {
            internal global::AssimpNet.Unmanaged.String.__Internal mName;
            internal uint mNumKeys;
            internal __IntPtr mKeys;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.MeshMorphAnim> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.MeshMorphAnim>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.MeshMorphAnim managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.MeshMorphAnim managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static MeshMorphAnim __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new MeshMorphAnim(native.ToPointer(), skipVTables);
        }

        internal static MeshMorphAnim __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (MeshMorphAnim)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static MeshMorphAnim __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MeshMorphAnim(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MeshMorphAnim(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected MeshMorphAnim(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Name of the mesh to be animated. An empty string is not allowed,</para>
        /// <para>animated meshes need to be named (not necessarily uniquely,</para>
        /// <para>the name can basically serve as wildcard to select a group</para>
        /// <para>of meshes with similar animation setup)</para>
        /// </summary>
        public global::AssimpNet.Unmanaged.String MName
        {
            get
            {
                return global::AssimpNet.Unmanaged.String.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->mName));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->mName = *(global::AssimpNet.Unmanaged.String.__Internal*) value.__Instance;
            }
        }

        /// <summary>Size of the #mKeys array. Must be 1, at least.</summary>
        public uint MNumKeys
        {
            get
            {
                return ((__Internal*)__Instance)->mNumKeys;
            }

            set
            {
                ((__Internal*)__Instance)->mNumKeys = value;
            }
        }

        /// <summary>Key frames of the animation. May not be nullptr.</summary>
        public global::AssimpNet.Unmanaged.MeshMorphKey MKeys
        {
            get
            {
                var __result0 = global::AssimpNet.Unmanaged.MeshMorphKey.__GetOrCreateInstance(((__Internal*)__Instance)->mKeys, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->mKeys = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>
    /// <para>An animation consists of key-frame data for a number of nodes. For</para>
    /// <para>each node affected by the animation a separate series of data is given.</para>
    /// </summary>
    public unsafe partial class Animation : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1096)]
        public partial struct __Internal
        {
            internal global::AssimpNet.Unmanaged.String.__Internal mName;
            internal double mDuration;
            internal double mTicksPerSecond;
            internal uint mNumChannels;
            internal __IntPtr mChannels;
            internal uint mNumMeshChannels;
            internal __IntPtr mMeshChannels;
            internal uint mNumMorphMeshChannels;
            internal __IntPtr mMorphMeshChannels;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.Animation> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.Animation>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.Animation managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.Animation managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Animation __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Animation(native.ToPointer(), skipVTables);
        }

        internal static Animation __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Animation)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Animation __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Animation(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Animation(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Animation(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>The name of the animation. If the modeling package this data was</para>
        /// <para>exported from does support only a single animation channel, this</para>
        /// <para>name is usually empty (length is zero).</para>
        /// </summary>
        public global::AssimpNet.Unmanaged.String MName
        {
            get
            {
                return global::AssimpNet.Unmanaged.String.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->mName));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->mName = *(global::AssimpNet.Unmanaged.String.__Internal*) value.__Instance;
            }
        }

        /// <summary>Duration of the animation in ticks.</summary>
        public double MDuration
        {
            get
            {
                return ((__Internal*)__Instance)->mDuration;
            }

            set
            {
                ((__Internal*)__Instance)->mDuration = value;
            }
        }

        /// <summary>Ticks per second. 0 if not specified in the imported file</summary>
        public double MTicksPerSecond
        {
            get
            {
                return ((__Internal*)__Instance)->mTicksPerSecond;
            }

            set
            {
                ((__Internal*)__Instance)->mTicksPerSecond = value;
            }
        }

        /// <summary>
        /// <para>The number of bone animation channels. Each channel affects</para>
        /// <para>a single node.</para>
        /// </summary>
        public uint MNumChannels
        {
            get
            {
                return ((__Internal*)__Instance)->mNumChannels;
            }

            set
            {
                ((__Internal*)__Instance)->mNumChannels = value;
            }
        }

        /// <summary>
        /// <para>The node animation channels. Each channel affects a single node.</para>
        /// <para>The array is mNumChannels in size.</para>
        /// </summary>
        public global::AssimpNet.Unmanaged.NodeAnim MChannels
        {
            get
            {
                var __result0 = global::AssimpNet.Unmanaged.NodeAnim.__GetOrCreateInstance(((__Internal*)__Instance)->mChannels, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->mChannels = new __IntPtr(&__value);
            }
        }

        /// <summary>
        /// <para>The number of mesh animation channels. Each channel affects</para>
        /// <para>a single mesh and defines vertex-based animation.</para>
        /// </summary>
        public uint MNumMeshChannels
        {
            get
            {
                return ((__Internal*)__Instance)->mNumMeshChannels;
            }

            set
            {
                ((__Internal*)__Instance)->mNumMeshChannels = value;
            }
        }

        /// <summary>
        /// <para>The mesh animation channels. Each channel affects a single mesh.</para>
        /// <para>The array is mNumMeshChannels in size.</para>
        /// </summary>
        public global::AssimpNet.Unmanaged.MeshAnim MMeshChannels
        {
            get
            {
                var __result0 = global::AssimpNet.Unmanaged.MeshAnim.__GetOrCreateInstance(((__Internal*)__Instance)->mMeshChannels, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->mMeshChannels = new __IntPtr(&__value);
            }
        }

        /// <summary>
        /// <para>The number of mesh animation channels. Each channel affects</para>
        /// <para>a single mesh and defines morphing animation.</para>
        /// </summary>
        public uint MNumMorphMeshChannels
        {
            get
            {
                return ((__Internal*)__Instance)->mNumMorphMeshChannels;
            }

            set
            {
                ((__Internal*)__Instance)->mNumMorphMeshChannels = value;
            }
        }

        /// <summary>
        /// <para>The morph mesh animation channels. Each channel affects a single mesh.</para>
        /// <para>The array is mNumMorphMeshChannels in size.</para>
        /// </summary>
        public global::AssimpNet.Unmanaged.MeshMorphAnim MMorphMeshChannels
        {
            get
            {
                var __result0 = global::AssimpNet.Unmanaged.MeshMorphAnim.__GetOrCreateInstance(((__Internal*)__Instance)->mMorphMeshChannels, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->mMorphMeshChannels = new __IntPtr(&__value);
            }
        }
    }
}
