// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace AssimpNet.Unmanaged
{
    /// <summary>
    /// <para>Defines how the Nth texture of a specific type is combined with</para>
    /// <para>the result of all previous layers.</para>
    /// </summary>
    /// <remarks>
    /// <para>Example (left: key, right: value):</para>
    /// <para>Written as equation, the final diffuse term for a specific pixel would be:</para>
    /// <para>where 'diffContrib' is the intensity of the incoming light for that pixel.</para>
    /// </remarks>
    public enum TextureOp
    {
        /// <summary>T = T1 * T2</summary>
        TextureOpMultiply = 0,
        /// <summary>T = T1 + T2</summary>
        TextureOpAdd = 1,
        /// <summary>T = T1 - T2</summary>
        TextureOpSubtract = 2,
        /// <summary>T = T1 / T2</summary>
        TextureOpDivide = 3,
        /// <summary>T = (T1 + T2) - (T1 * T2)</summary>
        TextureOpSmoothAdd = 4,
        /// <summary>T = T1 + (T2-0.5)</summary>
        TextureOpSignedAdd = 5,
        AiTextureOpForce32Bit = 2147483647
    }

    /// <summary>Defines how UV coordinates outside the [0...1] range are handled.</summary>
    /// <remarks>Commonly referred to as 'wrapping mode'.</remarks>
    public enum TextureMapMode
    {
        /// <summary>A texture coordinate u|v is translated to u%1|v%1</summary>
        TextureMapModeWrap = 0,
        /// <summary>
        /// <para>Texture coordinates outside [0...1]</para>
        /// <para>are clamped to the nearest valid value.</para>
        /// </summary>
        TextureMapModeClamp = 1,
        /// <summary>
        /// <para>If the texture coordinates for a pixel are outside [0...1]</para>
        /// <para>the texture is not applied to that pixel</para>
        /// </summary>
        TextureMapModeDecal = 3,
        /// <summary>
        /// <para>A texture coordinate u|v becomes u%1|v%1 if (u-(u%1))%2 is zero and</para>
        /// <para>1-(u%1)|1-(v%1) otherwise</para>
        /// </summary>
        TextureMapModeMirror = 2,
        AiTextureMapModeForce32Bit = 2147483647
    }

    /// <summary>Defines how the mapping coords for a texture are generated.</summary>
    /// <remarks>
    /// <para>Real-time applications typically require full UV coordinates, so the use of</para>
    /// <para>the aiProcess_GenUVCoords step is highly recommended. It generates proper</para>
    /// <para>UV channels for non-UV mapped objects, as long as an accurate description</para>
    /// <para>how the mapping should look like (e.g spherical) is given.</para>
    /// <para>See the #AI_MATKEY_MAPPING property for more details.</para>
    /// </remarks>
    public enum TextureMapping
    {
        /// <summary>The mapping coordinates are taken from an UV channel.</summary>
        /// <remarks>
        /// <para>#AI_MATKEY_UVWSRC property specifies from which UV channel</para>
        /// <para>the texture coordinates are to be taken from (remember,</para>
        /// <para>meshes can have more than one UV channel).</para>
        /// </remarks>
        TextureMappingUV = 0,
        /// <summary>Spherical mapping</summary>
        TextureMappingSPHERE = 1,
        /// <summary>Cylindrical mapping</summary>
        TextureMappingCYLINDER = 2,
        /// <summary>Cubic mapping</summary>
        TextureMappingBOX = 3,
        /// <summary>Planar mapping</summary>
        TextureMappingPLANE = 4,
        /// <summary>Undefined mapping. Have fun.</summary>
        TextureMappingOTHER = 5,
        AiTextureMappingForce32Bit = 2147483647
    }

    /// <summary>Defines the purpose of a texture</summary>
    /// <remarks>
    /// <para>This is a very difficult topic. Different 3D packages support different</para>
    /// <para>kinds of textures. For very common texture types, such as bumpmaps, the</para>
    /// <para>rendering results depend on implementation details in the rendering</para>
    /// <para>pipelines of these applications. Assimp loads all texture references from</para>
    /// <para>the model file and tries to determine which of the predefined texture</para>
    /// <para>types below is the best choice to match the original use of the texture</para>
    /// <para>as closely as possible.</para>
    /// <para>In content pipelines you'll usually define how textures have to be handled,</para>
    /// <para>and the artists working on models have to conform to this specification,</para>
    /// <para>regardless which 3D tool they're using.</para>
    /// </remarks>
    public enum TextureType
    {
        /// <summary>Dummy value.</summary>
        /// <remarks>
        /// <para>No texture, but the value to be used as 'texture semantic'</para>
        /// <para>(#aiMaterialProperty::mSemantic) for all material properties</para>
        /// <para>*not* related to textures.</para>
        /// </remarks>
        TextureTypeNONE = 0,
        /// <summary>
        /// <para>The texture is combined with the result of the diffuse</para>
        /// <para>lighting equation.</para>
        /// <para>OR</para>
        /// <para>PBR Specular/Glossiness</para>
        /// </summary>
        TextureTypeDIFFUSE = 1,
        /// <summary>
        /// <para>The texture is combined with the result of the specular</para>
        /// <para>lighting equation.</para>
        /// <para>OR</para>
        /// <para>PBR Specular/Glossiness</para>
        /// </summary>
        TextureTypeSPECULAR = 2,
        /// <summary>
        /// <para>The texture is combined with the result of the ambient</para>
        /// <para>lighting equation.</para>
        /// </summary>
        TextureTypeAMBIENT = 3,
        /// <summary>
        /// <para>The texture is added to the result of the lighting</para>
        /// <para>calculation. It isn't influenced by incoming light.</para>
        /// </summary>
        TextureTypeEMISSIVE = 4,
        /// <summary>The texture is a height map.</summary>
        /// <remarks>
        /// <para>By convention, higher gray-scale values stand for</para>
        /// <para>higher elevations from the base height.</para>
        /// </remarks>
        TextureTypeHEIGHT = 5,
        /// <summary>The texture is a (tangent space) normal-map.</summary>
        /// <remarks>
        /// <para>Again, there are several conventions for tangent-space</para>
        /// <para>normal maps. Assimp does (intentionally) not</para>
        /// <para>distinguish here.</para>
        /// </remarks>
        TextureTypeNORMALS = 6,
        /// <summary>The texture defines the glossiness of the material.</summary>
        /// <remarks>
        /// <para>The glossiness is in fact the exponent of the specular</para>
        /// <para>(phong) lighting equation. Usually there is a conversion</para>
        /// <para>function defined to map the linear color values in the</para>
        /// <para>texture to a suitable exponent. Have fun.</para>
        /// </remarks>
        TextureTypeSHININESS = 7,
        /// <summary>The texture defines per-pixel opacity.</summary>
        /// <remarks>
        /// <para>Usually 'white' means opaque and 'black' means</para>
        /// <para>'transparency'. Or quite the opposite. Have fun.</para>
        /// </remarks>
        TextureTypeOPACITY = 8,
        /// <summary>Displacement texture</summary>
        /// <remarks>
        /// <para>The exact purpose and format is application-dependent.</para>
        /// <para>Higher color values stand for higher vertex displacements.</para>
        /// </remarks>
        TextureTypeDISPLACEMENT = 9,
        /// <summary>Lightmap texture (aka Ambient Occlusion)</summary>
        /// <remarks>
        /// <para>Both 'Lightmaps' and dedicated 'ambient occlusion maps' are</para>
        /// <para>covered by this material property. The texture contains a</para>
        /// <para>scaling value for the final color value of a pixel. Its</para>
        /// <para>intensity is not affected by incoming light.</para>
        /// </remarks>
        TextureTypeLIGHTMAP = 10,
        /// <summary>Reflection texture</summary>
        /// <remarks>
        /// <para>Contains the color of a perfect mirror reflection.</para>
        /// <para>Rarely used, almost never for real-time applications.</para>
        /// </remarks>
        TextureTypeREFLECTION = 11,
        /// <summary>
        /// <para>PBR Materials</para>
        /// <para>PBR definitions from maya and other modelling packages now use this standard.</para>
        /// <para>This was originally introduced around 2012.</para>
        /// <para>Support for this is in game engines like Godot, Unreal or Unity3D.</para>
        /// <para>Modelling packages which use this are very common now.</para>
        /// </summary>
        TextureTypeBASE_COLOR = 12,
        /// <summary>
        /// <para>PBR Materials</para>
        /// <para>PBR definitions from maya and other modelling packages now use this standard.</para>
        /// <para>This was originally introduced around 2012.</para>
        /// <para>Support for this is in game engines like Godot, Unreal or Unity3D.</para>
        /// <para>Modelling packages which use this are very common now.</para>
        /// </summary>
        TextureTypeNORMAL_CAMERA = 13,
        /// <summary>
        /// <para>PBR Materials</para>
        /// <para>PBR definitions from maya and other modelling packages now use this standard.</para>
        /// <para>This was originally introduced around 2012.</para>
        /// <para>Support for this is in game engines like Godot, Unreal or Unity3D.</para>
        /// <para>Modelling packages which use this are very common now.</para>
        /// </summary>
        TextureTypeEMISSION_COLOR = 14,
        /// <summary>
        /// <para>PBR Materials</para>
        /// <para>PBR definitions from maya and other modelling packages now use this standard.</para>
        /// <para>This was originally introduced around 2012.</para>
        /// <para>Support for this is in game engines like Godot, Unreal or Unity3D.</para>
        /// <para>Modelling packages which use this are very common now.</para>
        /// </summary>
        TextureTypeMETALNESS = 15,
        /// <summary>
        /// <para>PBR Materials</para>
        /// <para>PBR definitions from maya and other modelling packages now use this standard.</para>
        /// <para>This was originally introduced around 2012.</para>
        /// <para>Support for this is in game engines like Godot, Unreal or Unity3D.</para>
        /// <para>Modelling packages which use this are very common now.</para>
        /// </summary>
        TextureTypeDIFFUSE_ROUGHNESS = 16,
        /// <summary>
        /// <para>PBR Materials</para>
        /// <para>PBR definitions from maya and other modelling packages now use this standard.</para>
        /// <para>This was originally introduced around 2012.</para>
        /// <para>Support for this is in game engines like Godot, Unreal or Unity3D.</para>
        /// <para>Modelling packages which use this are very common now.</para>
        /// </summary>
        TextureTypeAMBIENT_OCCLUSION = 17,
        /// <summary>Unknown texture</summary>
        /// <remarks>
        /// <para>A texture reference that does not match any of the definitions</para>
        /// <para>above is considered to be 'unknown'. It is still imported,</para>
        /// <para>but is excluded from any further post-processing.</para>
        /// </remarks>
        TextureTypeUNKNOWN = 18,
        /// <summary>
        /// <para>Sheen</para>
        /// <para>Generally used to simulate textiles that are covered in a layer of microfibers</para>
        /// <para>eg velvet</para>
        /// <para>https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen</para>
        /// </summary>
        TextureTypeSHEEN = 19,
        /// <summary>
        /// <para>Clearcoat</para>
        /// <para>Simulates a layer of 'polish' or 'lacquer' layered on top of a PBR substrate</para>
        /// <para>https://autodesk.github.io/standard-surface/#closures/coating</para>
        /// <para>https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat</para>
        /// </summary>
        TextureTypeCLEARCOAT = 20,
        /// <summary>
        /// <para>Transmission</para>
        /// <para>Simulates transmission through the surface</para>
        /// <para>May include further information such as wall thickness</para>
        /// </summary>
        TextureTypeTRANSMISSION = 21,
        /// <summary>Maya material declarations</summary>
        TextureTypeMAYA_BASE = 22,
        /// <summary>Maya material declarations</summary>
        TextureTypeMAYA_SPECULAR = 23,
        /// <summary>Maya material declarations</summary>
        TextureTypeMAYA_SPECULAR_COLOR = 24,
        /// <summary>Maya material declarations</summary>
        TextureTypeMAYA_SPECULAR_ROUGHNESS = 25,
        AiTextureTypeForce32Bit = 2147483647
    }

    /// <summary>Defines all shading models supported by the library</summary>
    /// <remarks>
    /// <para>Property: #AI_MATKEY_SHADING_MODEL</para>
    /// <para>The list of shading modes has been taken from Blender.</para>
    /// <para>See Blender documentation for more information. The API does</para>
    /// <para>not distinguish between &quot;specular&quot; and &quot;diffuse&quot; shaders (thus the</para>
    /// <para>specular term for diffuse shading models like Oren-Nayar remains</para>
    /// <para>undefined).</para>
    /// <para>Again, this value is just a hint. Assimp tries to select the shader whose</para>
    /// <para>most common implementation matches the original rendering results of the</para>
    /// <para>3D modeler which wrote a particular model as closely as possible.</para>
    /// </remarks>
    public enum ShadingMode
    {
        /// <summary>
        /// <para>Flat shading. Shading is done on per-face base,</para>
        /// <para>diffuse only. Also known as 'faceted shading'.</para>
        /// </summary>
        ShadingModeFlat = 1,
        /// <summary>Simple Gouraud shading.</summary>
        ShadingModeGouraud = 2,
        /// <summary>Phong-Shading -</summary>
        ShadingModePhong = 3,
        /// <summary>Phong-Blinn-Shading</summary>
        ShadingModeBlinn = 4,
        /// <summary>Toon-Shading per pixel</summary>
        /// <remarks>Also known as 'comic' shader.</remarks>
        ShadingModeToon = 5,
        /// <summary>OrenNayar-Shading per pixel</summary>
        /// <remarks>
        /// <para>Extension to standard Lambertian shading, taking the</para>
        /// <para>roughness of the material into account</para>
        /// </remarks>
        ShadingModeOrenNayar = 6,
        /// <summary>Minnaert-Shading per pixel</summary>
        /// <remarks>
        /// <para>Extension to standard Lambertian shading, taking the</para>
        /// <para>&quot;darkness&quot; of the material into account</para>
        /// </remarks>
        ShadingModeMinnaert = 7,
        /// <summary>CookTorrance-Shading per pixel</summary>
        /// <remarks>Special shader for metallic surfaces.</remarks>
        ShadingModeCookTorrance = 8,
        /// <summary>
        /// <para>No shading at all. Constant light influence of 1.0.</para>
        /// <para>Also known as &quot;Unlit&quot;</para>
        /// </summary>
        ShadingModeNoShading = 9,
        /// <summary>
        /// <para>No shading at all. Constant light influence of 1.0.</para>
        /// <para>Also known as &quot;Unlit&quot;</para>
        /// </summary>
        ShadingModeUnlit = 9,
        /// <summary>Fresnel shading</summary>
        ShadingModeFresnel = 10,
        /// <summary>
        /// <para>Physically-Based Rendering (PBR) shading using</para>
        /// <para>Bidirectional scattering/reflectance distribution function (BSDF/BRDF)</para>
        /// <para>There are multiple methods under this banner, and model files may provide</para>
        /// <para>data for more than one PBR-BRDF method.</para>
        /// <para>Applications should use the set of provided properties to determine which</para>
        /// <para>of their preferred PBR rendering methods are likely to be available</para>
        /// <para>eg:</para>
        /// <para>- If AI_MATKEY_METALLIC_FACTOR is set, then a Metallic/Roughness is available</para>
        /// <para>- If AI_MATKEY_GLOSSINESS_FACTOR is set, then a Specular/Glossiness is available</para>
        /// <para>Note that some PBR methods allow layering of techniques</para>
        /// </summary>
        ShadingModePBR_BRDF = 11,
        AiShadingModeForce32Bit = 2147483647
    }

    /// <remarks>
    /// <para>Defines some mixed flags for a particular texture.</para>
    /// <para>Usually you'll instruct your cg artists how textures have to look like ...</para>
    /// <para>and how they will be processed in your application. However, if you use</para>
    /// <para>Assimp for completely generic loading purposes you might also need to</para>
    /// <para>process these flags in order to display as many 'unknown' 3D models as</para>
    /// <para>possible correctly.</para>
    /// <para>This corresponds to the #AI_MATKEY_TEXFLAGS property.</para>
    /// </remarks>
    public enum TextureFlags
    {
        /// <summary>The texture's color values have to be inverted (component-wise 1-n)</summary>
        TextureFlagsInvert = 1,
        /// <summary>
        /// <para>Explicit request to the application to process the alpha channel</para>
        /// <para>of the texture.</para>
        /// </summary>
        /// <remarks>
        /// <para>Mutually exclusive with #aiTextureFlags_IgnoreAlpha. These</para>
        /// <para>flags are set if the library can say for sure that the alpha</para>
        /// <para>channel is used/is not used. If the model format does not</para>
        /// <para>define this, it is left to the application to decide whether</para>
        /// <para>the texture alpha channel - if any - is evaluated or not.</para>
        /// </remarks>
        TextureFlagsUseAlpha = 2,
        /// <summary>
        /// <para>Explicit request to the application to ignore the alpha channel</para>
        /// <para>of the texture.</para>
        /// </summary>
        /// <remarks>Mutually exclusive with #aiTextureFlags_UseAlpha.</remarks>
        TextureFlagsIgnoreAlpha = 4,
        AiTextureFlagsForce32Bit = 2147483647
    }

    /// <remarks>
    /// <para>Defines alpha-blend flags.</para>
    /// <para>If you're familiar with OpenGL or D3D, these flags aren't new to you.</para>
    /// <para>They define *how* the final color value of a pixel is computed, basing</para>
    /// <para>on the previous color at that pixel and the new color value from the</para>
    /// <para>material.</para>
    /// <para>The blend formula is:</para>
    /// <para>where DestColor is the previous color in the frame-buffer at this</para>
    /// <para>position and SourceColor is the material color before the transparency</para>
    /// <para>calculation.</para>
    /// <para>This corresponds to the #AI_MATKEY_BLEND_FUNC property.</para>
    /// </remarks>
    public enum BlendMode
    {
        /// <summary>Formula:</summary>
        BlendModeDefault = 0,
        /// <summary>Additive blending</summary>
        /// <remarks>Formula:</remarks>
        BlendModeAdditive = 1,
        AiBlendModeForce32Bit = 2147483647
    }

    /// <remarks>A very primitive RTTI system for the contents of material properties.</remarks>
    public enum PropertyTypeInfo
    {
        /// <summary>Array of single-precision (32 Bit) floats</summary>
        /// <remarks>
        /// <para>It is possible to use aiGetMaterialInteger[Array]() (or the C++-API</para>
        /// <para>aiMaterial::Get()) to query properties stored in floating-point format.</para>
        /// <para>The material system performs the type conversion automatically.</para>
        /// </remarks>
        PTI_Float = 1,
        /// <summary>Array of double-precision (64 Bit) floats</summary>
        /// <remarks>
        /// <para>It is possible to use aiGetMaterialInteger[Array]() (or the C++-API</para>
        /// <para>aiMaterial::Get()) to query properties stored in floating-point format.</para>
        /// <para>The material system performs the type conversion automatically.</para>
        /// </remarks>
        PTI_Double = 2,
        /// <summary>The material property is an aiString.</summary>
        /// <remarks>
        /// <para>Arrays of strings aren't possible, aiGetMaterialString() (or the</para>
        /// <para>C++-API aiMaterial::Get()) *must* be used to query a string property.</para>
        /// </remarks>
        PTI_String = 3,
        /// <summary>Array of (32 Bit) integers</summary>
        /// <remarks>
        /// <para>It is possible to use aiGetMaterialFloat[Array]() (or the C++-API</para>
        /// <para>aiMaterial::Get()) to query properties stored in integer format.</para>
        /// <para>The material system performs the type conversion automatically.</para>
        /// </remarks>
        PTI_Integer = 4,
        /// <summary>Simple binary buffer, content undefined. Not convertible to anything.</summary>
        PTI_Buffer = 5,
        AiPTI_Force32Bit = 2147483647
    }

    /// <remarks>
    /// <para>Defines how an UV channel is transformed.</para>
    /// <para>This is just a helper structure for the #AI_MATKEY_UVTRANSFORM key.</para>
    /// <para>See its documentation for more details.</para>
    /// <para>Typically you'll want to build a matrix of this information. However,</para>
    /// <para>we keep separate scaling/translation/rotation values to make it</para>
    /// <para>easier to process and optimize UV transformations internally.</para>
    /// </remarks>
    public unsafe partial class UVTransform : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            internal global::System.Numerics.Vector2 mTranslation;
            internal global::System.Numerics.Vector2 mScaling;
            internal float mRotation;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.UVTransform> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.UVTransform>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.UVTransform managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.UVTransform managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UVTransform __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UVTransform(native.ToPointer(), skipVTables);
        }

        internal static UVTransform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UVTransform)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UVTransform __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UVTransform(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UVTransform(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UVTransform(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Translation on the u and v axes.</summary>
        /// <remarks>The default value is (0|0).</remarks>
        public global::System.Numerics.Vector2 MTranslation
        {
            get
            {
                return ((__Internal*)__Instance)->mTranslation;
            }

            set
            {
                ((__Internal*)__Instance)->mTranslation = value;
            }
        }

        /// <summary>Scaling on the u and v axes.</summary>
        /// <remarks>The default value is (1|1).</remarks>
        public global::System.Numerics.Vector2 MScaling
        {
            get
            {
                return ((__Internal*)__Instance)->mScaling;
            }

            set
            {
                ((__Internal*)__Instance)->mScaling = value;
            }
        }

        /// <summary>Rotation - in counter-clockwise direction.</summary>
        /// <remarks>
        /// <para>The rotation angle is specified in radians. The</para>
        /// <para>rotation center is 0.5f|0.5f. The default value</para>
        /// <para>0.f.</para>
        /// </remarks>
        public float MRotation
        {
            get
            {
                return ((__Internal*)__Instance)->mRotation;
            }

            set
            {
                ((__Internal*)__Instance)->mRotation = value;
            }
        }
    }

    /// <summary>Data structure for a single material property</summary>
    /// <remarks>
    /// <para>As an user, you'll probably never need to deal with this data structure.</para>
    /// <para>Just use the provided aiGetMaterialXXX() or aiMaterial::Get() family</para>
    /// <para>of functions to query material properties easily. Processing them</para>
    /// <para>manually is faster, but it is not the recommended way. It isn't worth</para>
    /// <para>the effort.</para>
    /// <para>Material property names follow a simple scheme:</para>
    /// <para>aiMaterial</para>
    /// </remarks>
    public unsafe partial class MaterialProperty : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1056)]
        public partial struct __Internal
        {
            internal global::AssimpNet.Unmanaged.String.__Internal mKey;
            internal uint mSemantic;
            internal uint mIndex;
            internal uint mDataLength;
            internal global::AssimpNet.Unmanaged.PropertyTypeInfo mType;
            internal __IntPtr mData;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.MaterialProperty> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.MaterialProperty>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.MaterialProperty managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.MaterialProperty managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static MaterialProperty __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new MaterialProperty(native.ToPointer(), skipVTables);
        }

        internal static MaterialProperty __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (MaterialProperty)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static MaterialProperty __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MaterialProperty(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MaterialProperty(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected MaterialProperty(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Specifies the name of the property (key)</para>
        /// <para>Keys are generally case insensitive.</para>
        /// </summary>
        public global::AssimpNet.Unmanaged.String MKey
        {
            get
            {
                return global::AssimpNet.Unmanaged.String.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->mKey));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->mKey = *(global::AssimpNet.Unmanaged.String.__Internal*) value.__Instance;
            }
        }

        /// <summary>
        /// <para>Textures: Specifies their exact usage semantic.</para>
        /// <para>For non-texture properties, this member is always 0</para>
        /// <para>(or, better-said, #aiTextureType_NONE).</para>
        /// </summary>
        public uint MSemantic
        {
            get
            {
                return ((__Internal*)__Instance)->mSemantic;
            }

            set
            {
                ((__Internal*)__Instance)->mSemantic = value;
            }
        }

        /// <summary>
        /// <para>Textures: Specifies the index of the texture.</para>
        /// <para>For non-texture properties, this member is always 0.</para>
        /// </summary>
        public uint MIndex
        {
            get
            {
                return ((__Internal*)__Instance)->mIndex;
            }

            set
            {
                ((__Internal*)__Instance)->mIndex = value;
            }
        }

        /// <summary>
        /// <para>Size of the buffer mData is pointing to, in bytes.</para>
        /// <para>This value may not be 0.</para>
        /// </summary>
        public uint MDataLength
        {
            get
            {
                return ((__Internal*)__Instance)->mDataLength;
            }

            set
            {
                ((__Internal*)__Instance)->mDataLength = value;
            }
        }

        /// <summary>Type information for the property.</summary>
        /// <remarks>
        /// <para>Defines the data layout inside the data buffer. This is used</para>
        /// <para>by the library internally to perform debug checks and to</para>
        /// <para>utilize proper type conversions.</para>
        /// <para>(It's probably a hacky solution, but it works.)</para>
        /// </remarks>
        public global::AssimpNet.Unmanaged.PropertyTypeInfo MType
        {
            get
            {
                return ((__Internal*)__Instance)->mType;
            }

            set
            {
                ((__Internal*)__Instance)->mType = value;
            }
        }

        /// <summary>
        /// <para>Binary buffer to hold the property's value.</para>
        /// <para>The size of the buffer is always mDataLength.</para>
        /// </summary>
        public sbyte* MData
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->mData;
            }

            set
            {
                ((__Internal*)__Instance)->mData = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class Material : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr mProperties;
            internal uint mNumProperties;
            internal uint mNumAllocated;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.Material> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.Material>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.Material managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.Material managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Material __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Material(native.ToPointer(), skipVTables);
        }

        internal static Material __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Material)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Material __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Material(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Material(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Material(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>List of all material properties loaded.</summary>
        public global::AssimpNet.Unmanaged.MaterialProperty MProperties
        {
            get
            {
                var __result0 = global::AssimpNet.Unmanaged.MaterialProperty.__GetOrCreateInstance(((__Internal*)__Instance)->mProperties, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->mProperties = new __IntPtr(&__value);
            }
        }

        /// <summary>Number of properties in the data base</summary>
        public uint MNumProperties
        {
            get
            {
                return ((__Internal*)__Instance)->mNumProperties;
            }

            set
            {
                ((__Internal*)__Instance)->mNumProperties = value;
            }
        }

        /// <summary>Storage allocated</summary>
        public uint MNumAllocated
        {
            get
            {
                return ((__Internal*)__Instance)->mNumAllocated;
            }

            set
            {
                ((__Internal*)__Instance)->mNumAllocated = value;
            }
        }
    }

    public unsafe partial class material
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiTextureTypeToString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr TextureTypeToString(global::AssimpNet.Unmanaged.TextureType @in);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiGetMaterialProperty", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::AssimpNet.Unmanaged.Return GetMaterialProperty(__IntPtr pMat, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pKey, uint type, uint index, __IntPtr pPropOut);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiGetMaterialFloatArray", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::AssimpNet.Unmanaged.Return GetMaterialFloatArray(__IntPtr pMat, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pKey, uint type, uint index, float* pOut, uint* pMax);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiGetMaterialFloat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::AssimpNet.Unmanaged.Return GetMaterialFloat(__IntPtr pMat, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pKey, uint type, uint index, float* pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiGetMaterialIntegerArray", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::AssimpNet.Unmanaged.Return GetMaterialIntegerArray(__IntPtr pMat, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pKey, uint type, uint index, int* pOut, uint* pMax);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiGetMaterialInteger", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::AssimpNet.Unmanaged.Return GetMaterialInteger(__IntPtr pMat, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pKey, uint type, uint index, int* pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiGetMaterialColor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::AssimpNet.Unmanaged.Return GetMaterialColor(__IntPtr pMat, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pKey, uint type, uint index, __IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiGetMaterialUVTransform", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::AssimpNet.Unmanaged.Return GetMaterialUVTransform(__IntPtr pMat, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pKey, uint type, uint index, __IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiGetMaterialString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::AssimpNet.Unmanaged.Return GetMaterialString(__IntPtr pMat, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pKey, uint type, uint index, __IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiGetMaterialTextureCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint GetMaterialTextureCount(__IntPtr pMat, global::AssimpNet.Unmanaged.TextureType type);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiGetMaterialTexture", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::AssimpNet.Unmanaged.Return GetMaterialTexture(__IntPtr mat, global::AssimpNet.Unmanaged.TextureType type, uint index, __IntPtr path, global::AssimpNet.Unmanaged.TextureMapping* mapping, uint* uvindex, float* blend, global::AssimpNet.Unmanaged.TextureOp* op, global::AssimpNet.Unmanaged.TextureMapMode* mapmode, uint* flags);
        }

        /// <summary>Get a string for a given aiTextureType</summary>
        /// <param name="in">The texture type</param>
        /// <returns>The description string for the texture type.</returns>
        public static string TextureTypeToString(global::AssimpNet.Unmanaged.TextureType @in)
        {
            var ___ret = __Internal.TextureTypeToString(@in);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Retrieve a material property with a specific key from the material</summary>
        /// <param name="pMat">Pointer to the input material. May not be NULL</param>
        /// <param name="pKey">Key to search for. One of the AI_MATKEY_XXX constants.</param>
        /// <param name="type">
        /// <para>Specifies the type of the texture to be retrieved (</para>
        /// <para>e.g. diffuse, specular, height map ...)</para>
        /// </param>
        /// <param name="index">Index of the texture to be retrieved.</param>
        /// <param name="pPropOut">
        /// <para>Pointer to receive a pointer to a valid aiMaterialProperty</para>
        /// <para>structure or NULL if the key has not been found.</para>
        /// </param>
        public static global::AssimpNet.Unmanaged.Return GetMaterialProperty(global::AssimpNet.Unmanaged.Material pMat, string pKey, uint type, uint index, global::AssimpNet.Unmanaged.MaterialProperty pPropOut)
        {
            var __arg0 = pMat is null ? __IntPtr.Zero : pMat.__Instance;
            var ____arg4 = pPropOut is null ? __IntPtr.Zero : pPropOut.__Instance;
            var __arg4 = new __IntPtr(&____arg4);
            var ___ret = __Internal.GetMaterialProperty(__arg0, pKey, type, index, __arg4);
            return ___ret;
        }

        /// <summary>
        /// <para>Retrieve an array of float values with a specific key</para>
        /// <para>from the material</para>
        /// </summary>
        /// <param name="pMat">Pointer to the input material. May not be NULL</param>
        /// <param name="pKey">Key to search for. One of the AI_MATKEY_XXX constants.</param>
        /// <param name="pOut">Pointer to a buffer to receive the result.</param>
        /// <param name="pMax">
        /// <para>Specifies the size of the given buffer, in float's.</para>
        /// <para>Receives the number of values (not bytes!) read.</para>
        /// </param>
        /// <param name="type">(see the code sample above)</param>
        /// <param name="index">(see the code sample above)</param>
        /// <returns>
        /// <para>Specifies whether the key has been found. If not, the output</para>
        /// <para>arrays remains unmodified and pMax is set to 0.</para>
        /// </returns>
        /// <remarks>
        /// <para>Pass one of the AI_MATKEY_XXX constants for the last three parameters (the</para>
        /// <para>example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)</para>
        /// </remarks>
        public static global::AssimpNet.Unmanaged.Return GetMaterialFloatArray(global::AssimpNet.Unmanaged.Material pMat, string pKey, uint type, uint index, ref float pOut, ref uint pMax)
        {
            var __arg0 = pMat is null ? __IntPtr.Zero : pMat.__Instance;
            fixed (float* __pOut4 = &pOut)
            {
                var __arg4 = __pOut4;
                fixed (uint* __pMax5 = &pMax)
                {
                    var __arg5 = __pMax5;
                    var ___ret = __Internal.GetMaterialFloatArray(__arg0, pKey, type, index, __arg4, __arg5);
                    return ___ret;
                }
            }
        }

        /// <summary>Retrieve a single float property with a specific key from the material.</summary>
        /// <param name="pMat">Pointer to the input material. May not be NULL</param>
        /// <param name="pKey">Key to search for. One of the AI_MATKEY_XXX constants.</param>
        /// <param name="pOut">Receives the output float.</param>
        /// <param name="type">(see the code sample above)</param>
        /// <param name="index">(see the code sample above)</param>
        /// <returns>
        /// <para>Specifies whether the key has been found. If not, the output</para>
        /// <para>float remains unmodified.</para>
        /// </returns>
        /// <remarks>
        /// <para>Pass one of the AI_MATKEY_XXX constants for the last three parameters (the</para>
        /// <para>example reads the #AI_MATKEY_SHININESS_STRENGTH property of the first diffuse texture)</para>
        /// </remarks>
        public static global::AssimpNet.Unmanaged.Return GetMaterialFloat(global::AssimpNet.Unmanaged.Material pMat, string pKey, uint type, uint index, ref float pOut)
        {
            var __arg0 = pMat is null ? __IntPtr.Zero : pMat.__Instance;
            fixed (float* __pOut4 = &pOut)
            {
                var __arg4 = __pOut4;
                var ___ret = __Internal.GetMaterialFloat(__arg0, pKey, type, index, __arg4);
                return ___ret;
            }
        }

        /// <summary>
        /// <para>Retrieve an array of integer values with a specific key</para>
        /// <para>from a material</para>
        /// </summary>
        /// <remarks>See the sample for aiGetMaterialFloatArray for more information.</remarks>
        public static global::AssimpNet.Unmanaged.Return GetMaterialIntegerArray(global::AssimpNet.Unmanaged.Material pMat, string pKey, uint type, uint index, ref int pOut, ref uint pMax)
        {
            var __arg0 = pMat is null ? __IntPtr.Zero : pMat.__Instance;
            fixed (int* __pOut4 = &pOut)
            {
                var __arg4 = __pOut4;
                fixed (uint* __pMax5 = &pMax)
                {
                    var __arg5 = __pMax5;
                    var ___ret = __Internal.GetMaterialIntegerArray(__arg0, pKey, type, index, __arg4, __arg5);
                    return ___ret;
                }
            }
        }

        /// <summary>Retrieve an integer property with a specific key from a material</summary>
        /// <remarks>See the sample for aiGetMaterialFloat for more information.</remarks>
        public static global::AssimpNet.Unmanaged.Return GetMaterialInteger(global::AssimpNet.Unmanaged.Material pMat, string pKey, uint type, uint index, ref int pOut)
        {
            var __arg0 = pMat is null ? __IntPtr.Zero : pMat.__Instance;
            fixed (int* __pOut4 = &pOut)
            {
                var __arg4 = __pOut4;
                var ___ret = __Internal.GetMaterialInteger(__arg0, pKey, type, index, __arg4);
                return ___ret;
            }
        }

        /// <summary>Retrieve a color value from the material property table</summary>
        /// <remarks>See the sample for aiGetMaterialFloat for more information</remarks>
        public static global::AssimpNet.Unmanaged.Return GetMaterialColor(global::AssimpNet.Unmanaged.Material pMat, string pKey, uint type, uint index, global::System.Numerics.Vector4 pOut)
        {
            var __arg0 = pMat is null ? __IntPtr.Zero : pMat.__Instance;
            var __arg4 = new IntPtr(&pOut);
            var ___ret = __Internal.GetMaterialColor(__arg0, pKey, type, index, __arg4);
            return ___ret;
        }

        /// <summary>Retrieve a aiUVTransform value from the material property table</summary>
        /// <remarks>See the sample for aiGetMaterialFloat for more information</remarks>
        public static global::AssimpNet.Unmanaged.Return GetMaterialUVTransform(global::AssimpNet.Unmanaged.Material pMat, string pKey, uint type, uint index, global::AssimpNet.Unmanaged.UVTransform pOut)
        {
            var __arg0 = pMat is null ? __IntPtr.Zero : pMat.__Instance;
            var __arg4 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var ___ret = __Internal.GetMaterialUVTransform(__arg0, pKey, type, index, __arg4);
            return ___ret;
        }

        /// <summary>Retrieve a string from the material property table</summary>
        /// <remarks>See the sample for aiGetMaterialFloat for more information.</remarks>
        public static global::AssimpNet.Unmanaged.Return GetMaterialString(global::AssimpNet.Unmanaged.Material pMat, string pKey, uint type, uint index, global::AssimpNet.Unmanaged.String pOut)
        {
            var __arg0 = pMat is null ? __IntPtr.Zero : pMat.__Instance;
            var __arg4 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var ___ret = __Internal.GetMaterialString(__arg0, pKey, type, index, __arg4);
            return ___ret;
        }

        /// <summary>Get the number of textures for a particular texture type.</summary>
        /// <param name="pMat">Pointer to the input material. May not be NULL</param>
        /// <param name="type">Texture type to check for</param>
        /// <returns>Number of textures for this type.</returns>
        /// <remarks>A texture can be easily queried using #aiGetMaterialTexture()</remarks>
        public static uint GetMaterialTextureCount(global::AssimpNet.Unmanaged.Material pMat, global::AssimpNet.Unmanaged.TextureType type)
        {
            var __arg0 = pMat is null ? __IntPtr.Zero : pMat.__Instance;
            var ___ret = __Internal.GetMaterialTextureCount(__arg0, type);
            return ___ret;
        }

        public static global::AssimpNet.Unmanaged.Return GetMaterialTexture(global::AssimpNet.Unmanaged.Material mat, global::AssimpNet.Unmanaged.TextureType type, uint index, global::AssimpNet.Unmanaged.String path, ref global::AssimpNet.Unmanaged.TextureMapping mapping, ref uint uvindex, ref float blend, ref global::AssimpNet.Unmanaged.TextureOp op, ref global::AssimpNet.Unmanaged.TextureMapMode mapmode, ref uint flags)
        {
            var __arg0 = mat is null ? __IntPtr.Zero : mat.__Instance;
            var __arg3 = path is null ? __IntPtr.Zero : path.__Instance;
            fixed (global::AssimpNet.Unmanaged.TextureMapping* __mapping4 = &mapping)
            {
                var __arg4 = __mapping4;
                fixed (uint* __uvindex5 = &uvindex)
                {
                    var __arg5 = __uvindex5;
                    fixed (float* __blend6 = &blend)
                    {
                        var __arg6 = __blend6;
                        fixed (global::AssimpNet.Unmanaged.TextureOp* __op7 = &op)
                        {
                            var __arg7 = __op7;
                            fixed (global::AssimpNet.Unmanaged.TextureMapMode* __mapmode8 = &mapmode)
                            {
                                var __arg8 = __mapmode8;
                                fixed (uint* __flags9 = &flags)
                                {
                                    var __arg9 = __flags9;
                                    var ___ret = __Internal.GetMaterialTexture(__arg0, type, index, __arg3, __arg4, __arg5, __arg6, __arg7, __arg8, __arg9);
                                    return ___ret;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
