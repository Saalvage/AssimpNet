// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace AssimpNet.Unmanaged
{
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LogStreamCallback([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string __0, sbyte* __1);

    /// <summary>Our own C boolean type</summary>
    public unsafe partial class FileIO
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.FileIO> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.FileIO>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.FileIO managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.FileIO managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static FileIO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new FileIO(native.ToPointer(), skipVTables);
        }

        internal static FileIO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (FileIO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static FileIO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new FileIO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private FileIO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected FileIO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>
    /// <para>C-API: Represents a log stream. A log stream receives all log messages and</para>
    /// <para>streams them _somewhere_.</para>
    /// </summary>
    /// <remarks>
    /// <para>aiGetPredefinedLogStream</para>
    /// <para>aiAttachLogStream</para>
    /// <para>aiDetachLogStream</para>
    /// </remarks>
    public unsafe partial class LogStream : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr callback;
            internal __IntPtr user;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.LogStream> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.LogStream>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.LogStream managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.LogStream managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static LogStream __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new LogStream(native.ToPointer(), skipVTables);
        }

        internal static LogStream __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (LogStream)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static LogStream __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new LogStream(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private LogStream(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected LogStream(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>callback to be called</summary>
        public global::AssimpNet.Unmanaged.LogStreamCallback Callback
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->callback;
                return __ptr0 == IntPtr.Zero? null : (global::AssimpNet.Unmanaged.LogStreamCallback) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::AssimpNet.Unmanaged.LogStreamCallback));
            }

            set
            {
                ((__Internal*)__Instance)->callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>user data to be passed to the callback</summary>
        public sbyte* User
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->user;
            }

            set
            {
                ((__Internal*)__Instance)->user = (__IntPtr) value;
            }
        }
    }

    /// <summary>C-API: Represents an opaque set of settings to be used during importing.</summary>
    /// <remarks>
    /// <para>aiCreatePropertyStore</para>
    /// <para>aiReleasePropertyStore</para>
    /// <para>aiImportFileExWithProperties</para>
    /// <para>aiSetPropertyInteger</para>
    /// <para>aiSetPropertyFloat</para>
    /// <para>aiSetPropertyString</para>
    /// <para>aiSetPropertyMatrix</para>
    /// </remarks>
    public unsafe partial class PropertyStore : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            internal sbyte sentinel;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.PropertyStore> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.PropertyStore>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.PropertyStore managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.PropertyStore managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static PropertyStore __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new PropertyStore(native.ToPointer(), skipVTables);
        }

        internal static PropertyStore __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (PropertyStore)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static PropertyStore __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PropertyStore(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PropertyStore(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected PropertyStore(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte Sentinel
        {
            get
            {
                return ((__Internal*)__Instance)->sentinel;
            }

            set
            {
                ((__Internal*)__Instance)->sentinel = value;
            }
        }
    }

    public unsafe partial class cimport
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiImportFile", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ImportFile([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pFile, uint pFlags);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiImportFileEx", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ImportFileEx([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pFile, uint pFlags, __IntPtr pFS);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiImportFileExWithProperties", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ImportFileExWithProperties([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pFile, uint pFlags, __IntPtr pFS, __IntPtr pProps);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiImportFileFromMemory", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ImportFileFromMemory([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pBuffer, uint pLength, uint pFlags, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pHint);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiImportFileFromMemoryWithProperties", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ImportFileFromMemoryWithProperties([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pBuffer, uint pLength, uint pFlags, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string pHint, __IntPtr pProps);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiApplyPostProcessing", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ApplyPostProcessing(__IntPtr pScene, uint pFlags);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiGetPredefinedLogStream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::AssimpNet.Unmanaged.LogStream.__Internal GetPredefinedLogStream(global::AssimpNet.Unmanaged.DefaultLogStream pStreams, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string file);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiAttachLogStream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AttachLogStream(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiEnableVerboseLogging", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void EnableVerboseLogging(int d);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiDetachLogStream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::AssimpNet.Unmanaged.Return DetachLogStream(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiDetachAllLogStreams", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DetachAllLogStreams();

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiReleaseImport", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ReleaseImport(__IntPtr pScene);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiGetErrorString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetErrorString();

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiIsExtensionSupported", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int IsExtensionSupported([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string szExtension);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiGetExtensionList", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetExtensionList(__IntPtr szOut);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiGetMemoryRequirements", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetMemoryRequirements(__IntPtr pIn, __IntPtr @in);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiGetEmbeddedTexture", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetEmbeddedTexture(__IntPtr pIn, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filename);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiCreatePropertyStore", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreatePropertyStore();

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiReleasePropertyStore", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ReleasePropertyStore(__IntPtr p);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiSetImportPropertyInteger", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetImportPropertyInteger(__IntPtr store, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string szName, int value);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiSetImportPropertyFloat", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetImportPropertyFloat(__IntPtr store, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string szName, float value);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiSetImportPropertyString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetImportPropertyString(__IntPtr store, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string szName, __IntPtr st);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiSetImportPropertyMatrix", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetImportPropertyMatrix(__IntPtr store, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string szName, __IntPtr mat);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiCreateQuaternionFromMatrix", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CreateQuaternionFromMatrix(__IntPtr quat, __IntPtr mat);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiDecomposeMatrix", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DecomposeMatrix(__IntPtr mat, __IntPtr scaling, __IntPtr rotation, __IntPtr position);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiTransposeMatrix4", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void TransposeMatrix4(__IntPtr mat);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiTransposeMatrix3", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void TransposeMatrix3(__IntPtr mat);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiTransformVecByMatrix3", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void TransformVecByMatrix3(__IntPtr vec, __IntPtr mat);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiTransformVecByMatrix4", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void TransformVecByMatrix4(__IntPtr vec, __IntPtr mat);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMultiplyMatrix4", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MultiplyMatrix4(__IntPtr dst, __IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMultiplyMatrix3", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MultiplyMatrix3(__IntPtr dst, __IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiIdentityMatrix3", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void IdentityMatrix3(__IntPtr mat);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiIdentityMatrix4", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void IdentityMatrix4(__IntPtr mat);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiGetImportFormatCount", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ulong GetImportFormatCount();

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiGetImportFormatDescription", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetImportFormatDescription(ulong pIndex);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector2AreEqual", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Vector2AreEqual(__IntPtr a, __IntPtr b);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector2AreEqualEpsilon", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Vector2AreEqualEpsilon(__IntPtr a, __IntPtr b, float epsilon);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector2Add", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Vector2Add(__IntPtr dst, __IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector2Subtract", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Vector2Subtract(__IntPtr dst, __IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector2Scale", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Vector2Scale(__IntPtr dst, float s);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector2SymMul", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Vector2SymMul(__IntPtr dst, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector2DivideByScalar", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Vector2DivideByScalar(__IntPtr dst, float s);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector2DivideByVector", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Vector2DivideByVector(__IntPtr dst, __IntPtr v);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector2Length", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float Vector2Length(__IntPtr v);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector2SquareLength", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float Vector2SquareLength(__IntPtr v);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector2Negate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Vector2Negate(__IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector2DotProduct", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float Vector2DotProduct(__IntPtr a, __IntPtr b);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector2Normalize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Vector2Normalize(__IntPtr v);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector3AreEqual", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Vector3AreEqual(__IntPtr a, __IntPtr b);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector3AreEqualEpsilon", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Vector3AreEqualEpsilon(__IntPtr a, __IntPtr b, float epsilon);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector3LessThan", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Vector3LessThan(__IntPtr a, __IntPtr b);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector3Add", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Vector3Add(__IntPtr dst, __IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector3Subtract", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Vector3Subtract(__IntPtr dst, __IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector3Scale", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Vector3Scale(__IntPtr dst, float s);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector3SymMul", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Vector3SymMul(__IntPtr dst, __IntPtr other);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector3DivideByScalar", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Vector3DivideByScalar(__IntPtr dst, float s);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector3DivideByVector", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Vector3DivideByVector(__IntPtr dst, __IntPtr v);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector3Length", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float Vector3Length(__IntPtr v);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector3SquareLength", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float Vector3SquareLength(__IntPtr v);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector3Negate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Vector3Negate(__IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector3DotProduct", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float Vector3DotProduct(__IntPtr a, __IntPtr b);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector3CrossProduct", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Vector3CrossProduct(__IntPtr dst, __IntPtr a, __IntPtr b);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector3Normalize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Vector3Normalize(__IntPtr v);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector3NormalizeSafe", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Vector3NormalizeSafe(__IntPtr v);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiVector3RotateByQuaternion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Vector3RotateByQuaternion(__IntPtr v, __IntPtr q);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix3FromMatrix4", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix3FromMatrix4(__IntPtr dst, __IntPtr mat);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix3FromQuaternion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix3FromQuaternion(__IntPtr mat, __IntPtr q);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix3AreEqual", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Matrix3AreEqual(__IntPtr a, __IntPtr b);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix3AreEqualEpsilon", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Matrix3AreEqualEpsilon(__IntPtr a, __IntPtr b, float epsilon);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix3Inverse", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix3Inverse(__IntPtr mat);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix3Determinant", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float Matrix3Determinant(__IntPtr mat);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix3RotationZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix3RotationZ(__IntPtr mat, float angle);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix3FromRotationAroundAxis", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix3FromRotationAroundAxis(__IntPtr mat, __IntPtr axis, float angle);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix3Translation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix3Translation(__IntPtr mat, __IntPtr translation);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix3FromTo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix3FromTo(__IntPtr mat, __IntPtr from, __IntPtr to);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix4FromMatrix3", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix4FromMatrix3(__IntPtr dst, __IntPtr mat);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix4FromScalingQuaternionPosition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix4FromScalingQuaternionPosition(__IntPtr mat, __IntPtr scaling, __IntPtr rotation, __IntPtr position);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix4Add", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix4Add(__IntPtr dst, __IntPtr src);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix4AreEqual", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Matrix4AreEqual(__IntPtr a, __IntPtr b);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix4AreEqualEpsilon", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Matrix4AreEqualEpsilon(__IntPtr a, __IntPtr b, float epsilon);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix4Inverse", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix4Inverse(__IntPtr mat);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix4Determinant", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float Matrix4Determinant(__IntPtr mat);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix4IsIdentity", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Matrix4IsIdentity(__IntPtr mat);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix4DecomposeIntoScalingEulerAnglesPosition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix4DecomposeIntoScalingEulerAnglesPosition(__IntPtr mat, __IntPtr scaling, __IntPtr rotation, __IntPtr position);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix4DecomposeIntoScalingAxisAnglePosition", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix4DecomposeIntoScalingAxisAnglePosition(__IntPtr mat, __IntPtr scaling, __IntPtr axis, float* angle, __IntPtr position);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix4DecomposeNoScaling", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix4DecomposeNoScaling(__IntPtr mat, __IntPtr rotation, __IntPtr position);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix4FromEulerAngles", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix4FromEulerAngles(__IntPtr mat, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix4RotationX", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix4RotationX(__IntPtr mat, float angle);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix4RotationY", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix4RotationY(__IntPtr mat, float angle);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix4RotationZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix4RotationZ(__IntPtr mat, float angle);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix4FromRotationAroundAxis", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix4FromRotationAroundAxis(__IntPtr mat, __IntPtr axis, float angle);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix4Translation", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix4Translation(__IntPtr mat, __IntPtr translation);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix4Scaling", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix4Scaling(__IntPtr mat, __IntPtr scaling);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiMatrix4FromTo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Matrix4FromTo(__IntPtr mat, __IntPtr from, __IntPtr to);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiQuaternionFromEulerAngles", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void QuaternionFromEulerAngles(__IntPtr q, float x, float y, float z);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiQuaternionFromAxisAngle", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void QuaternionFromAxisAngle(__IntPtr q, __IntPtr axis, float angle);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiQuaternionFromNormalizedQuaternion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void QuaternionFromNormalizedQuaternion(__IntPtr q, __IntPtr normalized);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiQuaternionAreEqual", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int QuaternionAreEqual(__IntPtr a, __IntPtr b);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiQuaternionAreEqualEpsilon", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int QuaternionAreEqualEpsilon(__IntPtr a, __IntPtr b, float epsilon);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiQuaternionNormalize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void QuaternionNormalize(__IntPtr q);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiQuaternionConjugate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void QuaternionConjugate(__IntPtr q);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiQuaternionMultiply", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void QuaternionMultiply(__IntPtr dst, __IntPtr q);

            [SuppressUnmanagedCodeSecurity, DllImport("assimp", EntryPoint = "aiQuaternionInterpolate", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void QuaternionInterpolate(__IntPtr dst, __IntPtr start, __IntPtr end, float factor);
        }

        /// <summary>Reads the given file and returns its content.</summary>
        /// <param name="pFile">
        /// <para>Path and filename of the file to be imported,</para>
        /// <para>expected to be a null-terminated c-string. NULL is not a valid value.</para>
        /// </param>
        /// <param name="pFlags">
        /// <para>Optional post processing steps to be executed after</para>
        /// <para>a successful import. Provide a bitwise combination of the</para>
        /// <para>#aiPostProcessSteps flags.</para>
        /// </param>
        /// <returns>Pointer to the imported data or NULL if the import failed.</returns>
        /// <remarks>
        /// <para>If the call succeeds, the imported data is returned in an aiScene structure.</para>
        /// <para>The data is intended to be read-only, it stays property of the ASSIMP</para>
        /// <para>library and will be stable until aiReleaseImport() is called. After you're</para>
        /// <para>done with it, call aiReleaseImport() to free the resources associated with</para>
        /// <para>this file. If the import fails, NULL is returned instead. Call</para>
        /// <para>aiGetErrorString() to retrieve a human-readable error text.</para>
        /// </remarks>
        public static global::AssimpNet.Unmanaged.Scene ImportFile(string pFile, uint pFlags)
        {
            var ___ret = __Internal.ImportFile(pFile, pFlags);
            var __result0 = global::AssimpNet.Unmanaged.Scene.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Reads the given file using user-defined I/O functions and returns</para>
        /// <para>its content.</para>
        /// </summary>
        /// <param name="pFile">
        /// <para>Path and filename of the file to be imported,</para>
        /// <para>expected to be a null-terminated c-string. NULL is not a valid value.</para>
        /// </param>
        /// <param name="pFlags">
        /// <para>Optional post processing steps to be executed after</para>
        /// <para>a successful import. Provide a bitwise combination of the</para>
        /// <para>#aiPostProcessSteps flags.</para>
        /// </param>
        /// <param name="pFS">
        /// <para>aiFileIO structure. Will be used to open the model file itself</para>
        /// <para>and any other files the loader needs to open.  Pass NULL to use the default</para>
        /// <para>implementation.</para>
        /// </param>
        /// <returns>Pointer to the imported data or NULL if the import failed.</returns>
        /// <remarks>
        /// <para>If the call succeeds, the imported data is returned in an aiScene structure.</para>
        /// <para>The data is intended to be read-only, it stays property of the ASSIMP</para>
        /// <para>library and will be stable until aiReleaseImport() is called. After you're</para>
        /// <para>done with it, call aiReleaseImport() to free the resources associated with</para>
        /// <para>this file. If the import fails, NULL is returned instead. Call</para>
        /// <para>aiGetErrorString() to retrieve a human-readable error text.</para>
        /// <para>Include.h&gt; for the definition of #aiFileIO.</para>
        /// </remarks>
        public static global::AssimpNet.Unmanaged.Scene ImportFileEx(string pFile, uint pFlags, global::AssimpNet.Unmanaged.FileIO pFS)
        {
            var __arg2 = pFS is null ? __IntPtr.Zero : pFS.__Instance;
            var ___ret = __Internal.ImportFileEx(pFile, pFlags, __arg2);
            var __result0 = global::AssimpNet.Unmanaged.Scene.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Same as #aiImportFileEx, but adds an extra parameter containing importer settings.</summary>
        /// <param name="pFile">
        /// <para>Path and filename of the file to be imported,</para>
        /// <para>expected to be a null-terminated c-string. NULL is not a valid value.</para>
        /// </param>
        /// <param name="pFlags">
        /// <para>Optional post processing steps to be executed after</para>
        /// <para>a successful import. Provide a bitwise combination of the</para>
        /// <para>#aiPostProcessSteps flags.</para>
        /// </param>
        /// <param name="pFS">
        /// <para>aiFileIO structure. Will be used to open the model file itself</para>
        /// <para>and any other files the loader needs to open.  Pass NULL to use the default</para>
        /// <para>implementation.</para>
        /// </param>
        /// <param name="pProps">#aiPropertyStore instance containing import settings.</param>
        /// <returns>Pointer to the imported data or NULL if the import failed.</returns>
        /// <remarks>
        /// <para>Include.h&gt; for the definition of #aiFileIO.</para>
        /// <para>aiImportFileEx</para>
        /// </remarks>
        public static global::AssimpNet.Unmanaged.Scene ImportFileExWithProperties(string pFile, uint pFlags, global::AssimpNet.Unmanaged.FileIO pFS, global::AssimpNet.Unmanaged.PropertyStore pProps)
        {
            var __arg2 = pFS is null ? __IntPtr.Zero : pFS.__Instance;
            var __arg3 = pProps is null ? __IntPtr.Zero : pProps.__Instance;
            var ___ret = __Internal.ImportFileExWithProperties(pFile, pFlags, __arg2, __arg3);
            var __result0 = global::AssimpNet.Unmanaged.Scene.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Reads the given file from a given memory buffer,</summary>
        /// <param name="pBuffer">Pointer to the file data</param>
        /// <param name="pLength">Length of pBuffer, in bytes</param>
        /// <param name="pFlags">
        /// <para>Optional post processing steps to be executed after</para>
        /// <para>a successful import. Provide a bitwise combination of the</para>
        /// <para>#aiPostProcessSteps flags. If you wish to inspect the imported</para>
        /// <para>scene first in order to fine-tune your post-processing setup,</para>
        /// <para>consider to use #aiApplyPostProcessing().</para>
        /// </param>
        /// <param name="pHint">
        /// <para>An additional hint to the library. If this is a non empty string,</para>
        /// <para>the library looks for a loader to support the file extension specified by pHint</para>
        /// <para>and passes the file to the first matching loader. If this loader is unable to</para>
        /// <para>completely the request, the library continues and tries to determine the file</para>
        /// <para>format on its own, a task that may or may not be successful.</para>
        /// <para>Check the return value, and you'll know ...</para>
        /// </param>
        /// <returns>A pointer to the imported data, NULL if the import failed.</returns>
        /// <remarks>
        /// <para>If the call succeeds, the contents of the file are returned as a pointer to an</para>
        /// <para>aiScene object. The returned data is intended to be read-only, the importer keeps</para>
        /// <para>ownership of the data and will destroy it upon destruction. If the import fails,</para>
        /// <para>NULL is returned.</para>
        /// <para>A human-readable error description can be retrieved by calling aiGetErrorString().</para>
        /// <para>This is a straightforward way to decode models from memory</para>
        /// <para>buffers, but it doesn't handle model formats that spread their</para>
        /// <para>data across multiple files or even directories. Examples include</para>
        /// <para>OBJ or MD3, which outsource parts of their material info into</para>
        /// <para>external scripts. If you need full functionality, provide</para>
        /// <para>a custom IOSystem to make Assimp find these files and use</para>
        /// <para>the regular aiImportFileEx()/aiImportFileExWithProperties() API.</para>
        /// </remarks>
        public static global::AssimpNet.Unmanaged.Scene ImportFileFromMemory(string pBuffer, uint pLength, uint pFlags, string pHint)
        {
            var ___ret = __Internal.ImportFileFromMemory(pBuffer, pLength, pFlags, pHint);
            var __result0 = global::AssimpNet.Unmanaged.Scene.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.</summary>
        /// <param name="pBuffer">Pointer to the file data</param>
        /// <param name="pLength">Length of pBuffer, in bytes</param>
        /// <param name="pFlags">
        /// <para>Optional post processing steps to be executed after</para>
        /// <para>a successful import. Provide a bitwise combination of the</para>
        /// <para>#aiPostProcessSteps flags. If you wish to inspect the imported</para>
        /// <para>scene first in order to fine-tune your post-processing setup,</para>
        /// <para>consider to use #aiApplyPostProcessing().</para>
        /// </param>
        /// <param name="pHint">
        /// <para>An additional hint to the library. If this is a non empty string,</para>
        /// <para>the library looks for a loader to support the file extension specified by pHint</para>
        /// <para>and passes the file to the first matching loader. If this loader is unable to</para>
        /// <para>completely the request, the library continues and tries to determine the file</para>
        /// <para>format on its own, a task that may or may not be successful.</para>
        /// <para>Check the return value, and you'll know ...</para>
        /// </param>
        /// <param name="pProps">#aiPropertyStore instance containing import settings.</param>
        /// <returns>A pointer to the imported data, NULL if the import failed.</returns>
        /// <remarks>
        /// <para>This is a straightforward way to decode models from memory</para>
        /// <para>buffers, but it doesn't handle model formats that spread their</para>
        /// <para>data across multiple files or even directories. Examples include</para>
        /// <para>OBJ or MD3, which outsource parts of their material info into</para>
        /// <para>external scripts. If you need full functionality, provide</para>
        /// <para>a custom IOSystem to make Assimp find these files and use</para>
        /// <para>the regular aiImportFileEx()/aiImportFileExWithProperties() API.</para>
        /// <para>aiImportFileFromMemory</para>
        /// </remarks>
        public static global::AssimpNet.Unmanaged.Scene ImportFileFromMemoryWithProperties(string pBuffer, uint pLength, uint pFlags, string pHint, global::AssimpNet.Unmanaged.PropertyStore pProps)
        {
            var __arg4 = pProps is null ? __IntPtr.Zero : pProps.__Instance;
            var ___ret = __Internal.ImportFileFromMemoryWithProperties(pBuffer, pLength, pFlags, pHint, __arg4);
            var __result0 = global::AssimpNet.Unmanaged.Scene.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Apply post-processing to an already-imported scene.</summary>
        /// <param name="pScene">Scene to work on.</param>
        /// <param name="pFlags">Provide a bitwise combination of the #aiPostProcessSteps flags.</param>
        /// <returns>
        /// <para>A pointer to the post-processed data. Post processing is done in-place,</para>
        /// <para>meaning this is still the same #aiScene which you passed for pScene. However,</para>
        /// <para>_if_ post-processing failed, the scene could now be NULL. That's quite a rare</para>
        /// <para>case, post processing steps are not really designed to 'fail'. To be exact,</para>
        /// <para>the #aiProcess_ValidateDataStructure flag is currently the only post processing step</para>
        /// <para>which can actually cause the scene to be reset to NULL.</para>
        /// </returns>
        /// <remarks>
        /// <para>This is strictly equivalent to calling #aiImportFile()/#aiImportFileEx with the</para>
        /// <para>same flags. However, you can use this separate function to inspect the imported</para>
        /// <para>scene first to fine-tune your post-processing setup.</para>
        /// </remarks>
        public static global::AssimpNet.Unmanaged.Scene ApplyPostProcessing(global::AssimpNet.Unmanaged.Scene pScene, uint pFlags)
        {
            var __arg0 = pScene is null ? __IntPtr.Zero : pScene.__Instance;
            var ___ret = __Internal.ApplyPostProcessing(__arg0, pFlags);
            var __result0 = global::AssimpNet.Unmanaged.Scene.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Get one of the predefine log streams. This is the quick'n'easy solution to</para>
        /// <para>access Assimp's log system. Attaching a log stream can slightly reduce Assimp's</para>
        /// <para>overall import performance.</para>
        /// </summary>
        /// <param name="pStreams">One of the #aiDefaultLogStream enumerated values.</param>
        /// <param name="file">
        /// <para>Solely for the #aiDefaultLogStream_FILE flag: specifies the file to write to.</para>
        /// <para>Pass NULL for all other flags.</para>
        /// </param>
        /// <returns>The log stream. callback is set to NULL if something went wrong.</returns>
        /// <remarks>
        /// <para>Usage is rather simple (this will stream the log to a file, named log.txt, and</para>
        /// <para>the stdout stream of the process:</para>
        /// </remarks>
        public static global::AssimpNet.Unmanaged.LogStream GetPredefinedLogStream(global::AssimpNet.Unmanaged.DefaultLogStream pStreams, string file)
        {
            var ___ret = __Internal.GetPredefinedLogStream(pStreams, file);
            return global::AssimpNet.Unmanaged.LogStream.__CreateInstance(___ret);
        }

        /// <summary>Attach a custom log stream to the libraries' logging system.</summary>
        /// <param name="stream">Describes the new log stream.</param>
        /// <remarks>
        /// <para>Attaching a log stream can slightly reduce Assimp's overall import</para>
        /// <para>performance. Multiple log-streams can be attached.</para>
        /// <para>To ensure proper destruction of the logging system, you need to manually</para>
        /// <para>call aiDetachLogStream() on every single log stream you attach.</para>
        /// <para>Alternatively (for the lazy folks) #aiDetachAllLogStreams is provided.</para>
        /// </remarks>
        public static void AttachLogStream(global::AssimpNet.Unmanaged.LogStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            __Internal.AttachLogStream(__arg0);
        }

        /// <summary>
        /// <para>Enable verbose logging. Verbose logging includes debug-related stuff and</para>
        /// <para>detailed import statistics. This can have severe impact on import performance</para>
        /// <para>and memory consumption. However, it might be useful to find out why a file</para>
        /// <para>didn't read correctly.</para>
        /// </summary>
        /// <param name="d">AI_TRUE or AI_FALSE, your decision.</param>
        public static void EnableVerboseLogging(int d)
        {
            __Internal.EnableVerboseLogging(d);
        }

        /// <summary>Detach a custom log stream from the libraries' logging system.</summary>
        /// <param name="stream">The log stream to be detached.</param>
        /// <returns>AI_SUCCESS if the log stream has been detached successfully.</returns>
        /// <remarks>
        /// <para>This is the counterpart of #aiAttachLogStream. If you attached a stream,</para>
        /// <para>don't forget to detach it again.</para>
        /// <para>aiDetachAllLogStreams</para>
        /// </remarks>
        public static global::AssimpNet.Unmanaged.Return DetachLogStream(global::AssimpNet.Unmanaged.LogStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.DetachLogStream(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Detach all active log streams from the libraries' logging system.</para>
        /// <para>This ensures that the logging system is terminated properly and all</para>
        /// <para>resources allocated by it are actually freed. If you attached a stream,</para>
        /// <para>don't forget to detach it again.</para>
        /// </summary>
        /// <remarks>
        /// <para>aiAttachLogStream</para>
        /// <para>aiDetachLogStream</para>
        /// </remarks>
        public static void DetachAllLogStreams()
        {
            __Internal.DetachAllLogStreams();
        }

        /// <summary>Releases all resources associated with the given import process.</summary>
        /// <param name="pScene">The imported data to release. NULL is a valid value.</param>
        /// <remarks>Call this function after you're done with the imported data.</remarks>
        public static void ReleaseImport(global::AssimpNet.Unmanaged.Scene pScene)
        {
            var __arg0 = pScene is null ? __IntPtr.Zero : pScene.__Instance;
            __Internal.ReleaseImport(__arg0);
        }

        /// <summary>Returns the error text of the last failed import process.</summary>
        /// <returns>
        /// <para>A textual description of the error that occurred at the last</para>
        /// <para>import process. NULL if there was no error. There can't be an error if you</para>
        /// <para>got a non-NULL #aiScene from #aiImportFile/#aiImportFileEx/#aiApplyPostProcessing.</para>
        /// </returns>
        public static string GetErrorString()
        {
            var ___ret = __Internal.GetErrorString();
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Returns whether a given file extension is supported by ASSIMP</summary>
        /// <param name="szExtension">
        /// <para>Extension for which the function queries support for.</para>
        /// <para>Must include a leading dot '.'. Example: &quot;.3ds&quot;, &quot;.md3&quot;</para>
        /// </param>
        /// <returns>AI_TRUE if the file extension is supported.</returns>
        public static int IsExtensionSupported(string szExtension)
        {
            var ___ret = __Internal.IsExtensionSupported(szExtension);
            return ___ret;
        }

        /// <summary>Get a list of all file extensions supported by ASSIMP.</summary>
        /// <param name="szOut">
        /// <para>String to receive the extension list.</para>
        /// <para>Format of the list: &quot;*.3ds;*.obj;*.dae&quot;. NULL is not a valid parameter.</para>
        /// </param>
        /// <remarks>
        /// <para>If a file extension is contained in the list this does, of course, not</para>
        /// <para>mean that ASSIMP is able to load all files with this extension.</para>
        /// </remarks>
        public static void GetExtensionList(global::AssimpNet.Unmanaged.String szOut)
        {
            var __arg0 = szOut is null ? __IntPtr.Zero : szOut.__Instance;
            __Internal.GetExtensionList(__arg0);
        }

        /// <summary>Get the approximated storage required by an imported asset</summary>
        /// <param name="pIn">Input asset.</param>
        /// <param name="in">Data structure to be filled.</param>
        public static void GetMemoryRequirements(global::AssimpNet.Unmanaged.Scene pIn, global::AssimpNet.Unmanaged.MemoryInfo @in)
        {
            var __arg0 = pIn is null ? __IntPtr.Zero : pIn.__Instance;
            var __arg1 = @in is null ? __IntPtr.Zero : @in.__Instance;
            __Internal.GetMemoryRequirements(__arg0, __arg1);
        }

        /// <summary>Returns an embedded texture, or nullptr.</summary>
        /// <param name="pIn">Input asset.</param>
        /// <param name="filename">Texture path extracted from aiGetMaterialString.</param>
        public static global::AssimpNet.Unmanaged.Texture GetEmbeddedTexture(global::AssimpNet.Unmanaged.Scene pIn, string filename)
        {
            var __arg0 = pIn is null ? __IntPtr.Zero : pIn.__Instance;
            var ___ret = __Internal.GetEmbeddedTexture(__arg0, filename);
            var __result0 = global::AssimpNet.Unmanaged.Texture.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Create an empty property store. Property stores are used to collect import</para>
        /// <para>settings.</para>
        /// </summary>
        /// <returns>
        /// <para>New property store. Property stores need to be manually destroyed using</para>
        /// <para>the #aiReleasePropertyStore API function.</para>
        /// </returns>
        public static global::AssimpNet.Unmanaged.PropertyStore CreatePropertyStore()
        {
            var ___ret = __Internal.CreatePropertyStore();
            var __result0 = global::AssimpNet.Unmanaged.PropertyStore.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Delete a property store.</summary>
        /// <param name="p">Property store to be deleted.</param>
        public static void ReleasePropertyStore(global::AssimpNet.Unmanaged.PropertyStore p)
        {
            var __arg0 = p is null ? __IntPtr.Zero : p.__Instance;
            __Internal.ReleasePropertyStore(__arg0);
        }

        /// <summary>Set an integer property.</summary>
        /// <param name="store">Store to modify. Use #aiCreatePropertyStore to obtain a store.</param>
        /// <param name="szName">
        /// <para>Name of the configuration property to be set. All supported</para>
        /// <para>public properties are defined in the config.h header file (AI_CONFIG_XXX).</para>
        /// </param>
        /// <param name="value">New value for the property</param>
        /// <remarks>
        /// <para>This is the C-version of #Assimp::Importer::SetPropertyInteger(). In the C</para>
        /// <para>interface, properties are always shared by all imports. It is not possible to</para>
        /// <para>specify them per import.</para>
        /// </remarks>
        public static void SetImportPropertyInteger(global::AssimpNet.Unmanaged.PropertyStore store, string szName, int value)
        {
            var __arg0 = store is null ? __IntPtr.Zero : store.__Instance;
            __Internal.SetImportPropertyInteger(__arg0, szName, value);
        }

        /// <summary>Set a floating-point property.</summary>
        /// <param name="store">Store to modify. Use #aiCreatePropertyStore to obtain a store.</param>
        /// <param name="szName">
        /// <para>Name of the configuration property to be set. All supported</para>
        /// <para>public properties are defined in the config.h header file (AI_CONFIG_XXX).</para>
        /// </param>
        /// <param name="value">New value for the property</param>
        /// <remarks>
        /// <para>This is the C-version of #Assimp::Importer::SetPropertyFloat(). In the C</para>
        /// <para>interface, properties are always shared by all imports. It is not possible to</para>
        /// <para>specify them per import.</para>
        /// </remarks>
        public static void SetImportPropertyFloat(global::AssimpNet.Unmanaged.PropertyStore store, string szName, float value)
        {
            var __arg0 = store is null ? __IntPtr.Zero : store.__Instance;
            __Internal.SetImportPropertyFloat(__arg0, szName, value);
        }

        /// <summary>Set a string property.</summary>
        /// <param name="store">Store to modify. Use #aiCreatePropertyStore to obtain a store.</param>
        /// <param name="szName">
        /// <para>Name of the configuration property to be set. All supported</para>
        /// <para>public properties are defined in the config.h header file (AI_CONFIG_XXX).</para>
        /// </param>
        /// <param name="st">New value for the property</param>
        /// <remarks>
        /// <para>This is the C-version of #Assimp::Importer::SetPropertyString(). In the C</para>
        /// <para>interface, properties are always shared by all imports. It is not possible to</para>
        /// <para>specify them per import.</para>
        /// </remarks>
        public static void SetImportPropertyString(global::AssimpNet.Unmanaged.PropertyStore store, string szName, global::AssimpNet.Unmanaged.String st)
        {
            var __arg0 = store is null ? __IntPtr.Zero : store.__Instance;
            var __arg2 = st is null ? __IntPtr.Zero : st.__Instance;
            __Internal.SetImportPropertyString(__arg0, szName, __arg2);
        }

        /// <summary>Set a matrix property.</summary>
        /// <param name="store">Store to modify. Use #aiCreatePropertyStore to obtain a store.</param>
        /// <param name="szName">
        /// <para>Name of the configuration property to be set. All supported</para>
        /// <para>public properties are defined in the config.h header file (AI_CONFIG_XXX).</para>
        /// </param>
        /// <param name="mat">New value for the property</param>
        /// <remarks>
        /// <para>This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C</para>
        /// <para>interface, properties are always shared by all imports. It is not possible to</para>
        /// <para>specify them per import.</para>
        /// </remarks>
        public static void SetImportPropertyMatrix(global::AssimpNet.Unmanaged.PropertyStore store, string szName, global::System.Numerics.Matrix4x4 mat)
        {
            var __arg0 = store is null ? __IntPtr.Zero : store.__Instance;
            var __arg2 = new IntPtr(&mat);
            __Internal.SetImportPropertyMatrix(__arg0, szName, __arg2);
        }

        /// <summary>Construct a quaternion from a 3x3 rotation matrix.</summary>
        /// <param name="quat">Receives the output quaternion.</param>
        /// <param name="mat">Matrix to 'quaternionize'.</param>
        /// <remarks>aiQuaternion(const aiMatrix3x3&amp;pRotMatrix)</remarks>
        public static void CreateQuaternionFromMatrix(global::System.Numerics.Quaternion quat, global::AssimpNet.Unmanaged.Matrix3x3 mat)
        {
            var __arg0 = new IntPtr(&quat);
            var __arg1 = mat is null ? __IntPtr.Zero : mat.__Instance;
            __Internal.CreateQuaternionFromMatrix(__arg0, __arg1);
        }

        /// <summary>
        /// <para>Decompose a transformation matrix into its rotational, translational and</para>
        /// <para>scaling components.</para>
        /// </summary>
        /// <param name="mat">Matrix to decompose</param>
        /// <param name="scaling">Receives the scaling component</param>
        /// <param name="rotation">Receives the rotational component</param>
        /// <param name="position">Receives the translational component.</param>
        /// <remarks>aiMatrix4x4::Decompose (aiVector3D&amp;, aiQuaternion&amp;, aiVector3D&amp;) const;</remarks>
        public static void DecomposeMatrix(global::System.Numerics.Matrix4x4 mat, global::System.Numerics.Vector3 scaling, global::System.Numerics.Quaternion rotation, global::System.Numerics.Vector3 position)
        {
            var __arg0 = new IntPtr(&mat);
            var __arg1 = new IntPtr(&scaling);
            var __arg2 = new IntPtr(&rotation);
            var __arg3 = new IntPtr(&position);
            __Internal.DecomposeMatrix(__arg0, __arg1, __arg2, __arg3);
        }

        /// <summary>Transpose a 4x4 matrix.</summary>
        /// <param name="mat">Pointer to the matrix to be transposed</param>
        public static void TransposeMatrix4(global::System.Numerics.Matrix4x4 mat)
        {
            var __arg0 = new IntPtr(&mat);
            __Internal.TransposeMatrix4(__arg0);
        }

        /// <summary>Transpose a 3x3 matrix.</summary>
        /// <param name="mat">Pointer to the matrix to be transposed</param>
        public static void TransposeMatrix3(global::AssimpNet.Unmanaged.Matrix3x3 mat)
        {
            var __arg0 = mat is null ? __IntPtr.Zero : mat.__Instance;
            __Internal.TransposeMatrix3(__arg0);
        }

        /// <summary>Transform a vector by a 3x3 matrix</summary>
        /// <param name="vec">Vector to be transformed.</param>
        /// <param name="mat">Matrix to transform the vector with.</param>
        public static void TransformVecByMatrix3(global::System.Numerics.Vector3 vec, global::AssimpNet.Unmanaged.Matrix3x3 mat)
        {
            var __arg0 = new IntPtr(&vec);
            var __arg1 = mat is null ? __IntPtr.Zero : mat.__Instance;
            __Internal.TransformVecByMatrix3(__arg0, __arg1);
        }

        /// <summary>Transform a vector by a 4x4 matrix</summary>
        /// <param name="vec">Vector to be transformed.</param>
        /// <param name="mat">Matrix to transform the vector with.</param>
        public static void TransformVecByMatrix4(global::System.Numerics.Vector3 vec, global::System.Numerics.Matrix4x4 mat)
        {
            var __arg0 = new IntPtr(&vec);
            var __arg1 = new IntPtr(&mat);
            __Internal.TransformVecByMatrix4(__arg0, __arg1);
        }

        /// <summary>Multiply two 4x4 matrices.</summary>
        /// <param name="dst">First factor, receives result.</param>
        /// <param name="src">Matrix to be multiplied with 'dst'.</param>
        public static void MultiplyMatrix4(global::System.Numerics.Matrix4x4 dst, global::System.Numerics.Matrix4x4 src)
        {
            var __arg0 = new IntPtr(&dst);
            var __arg1 = new IntPtr(&src);
            __Internal.MultiplyMatrix4(__arg0, __arg1);
        }

        /// <summary>Multiply two 3x3 matrices.</summary>
        /// <param name="dst">First factor, receives result.</param>
        /// <param name="src">Matrix to be multiplied with 'dst'.</param>
        public static void MultiplyMatrix3(global::AssimpNet.Unmanaged.Matrix3x3 dst, global::AssimpNet.Unmanaged.Matrix3x3 src)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var __arg1 = src is null ? __IntPtr.Zero : src.__Instance;
            __Internal.MultiplyMatrix3(__arg0, __arg1);
        }

        /// <summary>Get a 3x3 identity matrix.</summary>
        /// <param name="mat">Matrix to receive its personal identity</param>
        public static void IdentityMatrix3(global::AssimpNet.Unmanaged.Matrix3x3 mat)
        {
            var __arg0 = mat is null ? __IntPtr.Zero : mat.__Instance;
            __Internal.IdentityMatrix3(__arg0);
        }

        /// <summary>Get a 4x4 identity matrix.</summary>
        /// <param name="mat">Matrix to receive its personal identity</param>
        public static void IdentityMatrix4(global::System.Numerics.Matrix4x4 mat)
        {
            var __arg0 = new IntPtr(&mat);
            __Internal.IdentityMatrix4(__arg0);
        }

        /// <summary>
        /// <para>Returns the number of import file formats available in the current Assimp build.</para>
        /// <para>Use aiGetImportFormatDescription() to retrieve infos of a specific import format.</para>
        /// </summary>
        public static ulong GetImportFormatCount()
        {
            var ___ret = __Internal.GetImportFormatCount();
            return ___ret;
        }

        /// <summary>
        /// <para>Returns a description of the nth import file format. Use #aiGetImportFormatCount()</para>
        /// <para>to learn how many import formats are supported.</para>
        /// </summary>
        /// <param name="pIndex">
        /// <para>Index of the import format to retrieve information for. Valid range is</para>
        /// <para>0 to #aiGetImportFormatCount()</para>
        /// </param>
        /// <returns>A description of that specific import format. NULL if pIndex is out of range.</returns>
        public static global::AssimpNet.Unmanaged.ImporterDesc GetImportFormatDescription(ulong pIndex)
        {
            var ___ret = __Internal.GetImportFormatDescription(pIndex);
            var __result0 = global::AssimpNet.Unmanaged.ImporterDesc.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Check if 2D vectors are equal.</summary>
        /// <param name="a">First vector to compare</param>
        /// <param name="b">Second vector to compare</param>
        /// <returns>1 if the vectors are equal</returns>
        /// <returns>0 if the vectors are not equal</returns>
        public static int Vector2AreEqual(global::System.Numerics.Vector2 a, global::System.Numerics.Vector2 b)
        {
            var __arg0 = new IntPtr(&a);
            var __arg1 = new IntPtr(&b);
            var ___ret = __Internal.Vector2AreEqual(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Check if 2D vectors are equal using epsilon.</summary>
        /// <param name="a">First vector to compare</param>
        /// <param name="b">Second vector to compare</param>
        /// <param name="epsilon">Epsilon</param>
        /// <returns>1 if the vectors are equal</returns>
        /// <returns>0 if the vectors are not equal</returns>
        public static int Vector2AreEqualEpsilon(global::System.Numerics.Vector2 a, global::System.Numerics.Vector2 b, float epsilon)
        {
            var __arg0 = new IntPtr(&a);
            var __arg1 = new IntPtr(&b);
            var ___ret = __Internal.Vector2AreEqualEpsilon(__arg0, __arg1, epsilon);
            return ___ret;
        }

        /// <summary>Add 2D vectors.</summary>
        /// <param name="dst">First addend, receives result.</param>
        /// <param name="src">Vector to be added to 'dst'.</param>
        public static void Vector2Add(global::System.Numerics.Vector2 dst, global::System.Numerics.Vector2 src)
        {
            var __arg0 = new IntPtr(&dst);
            var __arg1 = new IntPtr(&src);
            __Internal.Vector2Add(__arg0, __arg1);
        }

        /// <summary>Subtract 2D vectors.</summary>
        /// <param name="dst">Minuend, receives result.</param>
        /// <param name="src">Vector to be subtracted from 'dst'.</param>
        public static void Vector2Subtract(global::System.Numerics.Vector2 dst, global::System.Numerics.Vector2 src)
        {
            var __arg0 = new IntPtr(&dst);
            var __arg1 = new IntPtr(&src);
            __Internal.Vector2Subtract(__arg0, __arg1);
        }

        /// <summary>Multiply a 2D vector by a scalar.</summary>
        /// <param name="dst">Vector to be scaled by</param>
        /// <param name="s">Scale factor</param>
        public static void Vector2Scale(global::System.Numerics.Vector2 dst, float s)
        {
            var __arg0 = new IntPtr(&dst);
            __Internal.Vector2Scale(__arg0, s);
        }

        /// <summary>
        /// <para>Multiply each component of a 2D vector with</para>
        /// <para>the components of another vector.</para>
        /// </summary>
        /// <param name="dst">First vector, receives result</param>
        /// <param name="other">Second vector</param>
        public static void Vector2SymMul(global::System.Numerics.Vector2 dst, global::System.Numerics.Vector2 other)
        {
            var __arg0 = new IntPtr(&dst);
            var __arg1 = new IntPtr(&other);
            __Internal.Vector2SymMul(__arg0, __arg1);
        }

        /// <summary>Divide a 2D vector by a scalar.</summary>
        /// <param name="dst">Vector to be divided by</param>
        /// <param name="s">Scalar divisor</param>
        public static void Vector2DivideByScalar(global::System.Numerics.Vector2 dst, float s)
        {
            var __arg0 = new IntPtr(&dst);
            __Internal.Vector2DivideByScalar(__arg0, s);
        }

        /// <summary>
        /// <para>Divide each component of a 2D vector by</para>
        /// <para>the components of another vector.</para>
        /// </summary>
        /// <param name="dst">Vector as the dividend</param>
        /// <param name="v">Vector as the divisor</param>
        public static void Vector2DivideByVector(global::System.Numerics.Vector2 dst, global::System.Numerics.Vector2 v)
        {
            var __arg0 = new IntPtr(&dst);
            var __arg1 = new IntPtr(&v);
            __Internal.Vector2DivideByVector(__arg0, __arg1);
        }

        /// <summary>Get the length of a 2D vector.</summary>
        /// <returns>v Vector to evaluate</returns>
        public static float Vector2Length(global::System.Numerics.Vector2 v)
        {
            var __arg0 = new IntPtr(&v);
            var ___ret = __Internal.Vector2Length(__arg0);
            return ___ret;
        }

        /// <summary>Get the squared length of a 2D vector.</summary>
        /// <returns>v Vector to evaluate</returns>
        public static float Vector2SquareLength(global::System.Numerics.Vector2 v)
        {
            var __arg0 = new IntPtr(&v);
            var ___ret = __Internal.Vector2SquareLength(__arg0);
            return ___ret;
        }

        /// <summary>Negate a 2D vector.</summary>
        /// <param name="dst">Vector to be negated</param>
        public static void Vector2Negate(global::System.Numerics.Vector2 dst)
        {
            var __arg0 = new IntPtr(&dst);
            __Internal.Vector2Negate(__arg0);
        }

        /// <summary>Get the dot product of 2D vectors.</summary>
        /// <param name="a">First vector</param>
        /// <param name="b">Second vector</param>
        /// <returns>The dot product of vectors</returns>
        public static float Vector2DotProduct(global::System.Numerics.Vector2 a, global::System.Numerics.Vector2 b)
        {
            var __arg0 = new IntPtr(&a);
            var __arg1 = new IntPtr(&b);
            var ___ret = __Internal.Vector2DotProduct(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Normalize a 2D vector.</summary>
        /// <param name="v">Vector to normalize</param>
        public static void Vector2Normalize(global::System.Numerics.Vector2 v)
        {
            var __arg0 = new IntPtr(&v);
            __Internal.Vector2Normalize(__arg0);
        }

        /// <summary>Check if 3D vectors are equal.</summary>
        /// <param name="a">First vector to compare</param>
        /// <param name="b">Second vector to compare</param>
        /// <returns>1 if the vectors are equal</returns>
        /// <returns>0 if the vectors are not equal</returns>
        public static int Vector3AreEqual(global::System.Numerics.Vector3 a, global::System.Numerics.Vector3 b)
        {
            var __arg0 = new IntPtr(&a);
            var __arg1 = new IntPtr(&b);
            var ___ret = __Internal.Vector3AreEqual(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Check if 3D vectors are equal using epsilon.</summary>
        /// <param name="a">First vector to compare</param>
        /// <param name="b">Second vector to compare</param>
        /// <param name="epsilon">Epsilon</param>
        /// <returns>1 if the vectors are equal</returns>
        /// <returns>0 if the vectors are not equal</returns>
        public static int Vector3AreEqualEpsilon(global::System.Numerics.Vector3 a, global::System.Numerics.Vector3 b, float epsilon)
        {
            var __arg0 = new IntPtr(&a);
            var __arg1 = new IntPtr(&b);
            var ___ret = __Internal.Vector3AreEqualEpsilon(__arg0, __arg1, epsilon);
            return ___ret;
        }

        /// <summary>Check if vectoris less than vector</summary>
        /// <param name="a">First vector to compare</param>
        /// <param name="b">Second vector to compare</param>
        /// <param name="epsilon">Epsilon</param>
        /// <returns>1 ifis less than</returns>
        /// <returns>0 ifis equal or greater than</returns>
        public static int Vector3LessThan(global::System.Numerics.Vector3 a, global::System.Numerics.Vector3 b)
        {
            var __arg0 = new IntPtr(&a);
            var __arg1 = new IntPtr(&b);
            var ___ret = __Internal.Vector3LessThan(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Add 3D vectors.</summary>
        /// <param name="dst">First addend, receives result.</param>
        /// <param name="src">Vector to be added to 'dst'.</param>
        public static void Vector3Add(global::System.Numerics.Vector3 dst, global::System.Numerics.Vector3 src)
        {
            var __arg0 = new IntPtr(&dst);
            var __arg1 = new IntPtr(&src);
            __Internal.Vector3Add(__arg0, __arg1);
        }

        /// <summary>Subtract 3D vectors.</summary>
        /// <param name="dst">Minuend, receives result.</param>
        /// <param name="src">Vector to be subtracted from 'dst'.</param>
        public static void Vector3Subtract(global::System.Numerics.Vector3 dst, global::System.Numerics.Vector3 src)
        {
            var __arg0 = new IntPtr(&dst);
            var __arg1 = new IntPtr(&src);
            __Internal.Vector3Subtract(__arg0, __arg1);
        }

        /// <summary>Multiply a 3D vector by a scalar.</summary>
        /// <param name="dst">Vector to be scaled by</param>
        /// <param name="s">Scale factor</param>
        public static void Vector3Scale(global::System.Numerics.Vector3 dst, float s)
        {
            var __arg0 = new IntPtr(&dst);
            __Internal.Vector3Scale(__arg0, s);
        }

        /// <summary>
        /// <para>Multiply each component of a 3D vector with</para>
        /// <para>the components of another vector.</para>
        /// </summary>
        /// <param name="dst">First vector, receives result</param>
        /// <param name="other">Second vector</param>
        public static void Vector3SymMul(global::System.Numerics.Vector3 dst, global::System.Numerics.Vector3 other)
        {
            var __arg0 = new IntPtr(&dst);
            var __arg1 = new IntPtr(&other);
            __Internal.Vector3SymMul(__arg0, __arg1);
        }

        /// <summary>Divide a 3D vector by a scalar.</summary>
        /// <param name="dst">Vector to be divided by</param>
        /// <param name="s">Scalar divisor</param>
        public static void Vector3DivideByScalar(global::System.Numerics.Vector3 dst, float s)
        {
            var __arg0 = new IntPtr(&dst);
            __Internal.Vector3DivideByScalar(__arg0, s);
        }

        /// <summary>
        /// <para>Divide each component of a 3D vector by</para>
        /// <para>the components of another vector.</para>
        /// </summary>
        /// <param name="dst">Vector as the dividend</param>
        /// <param name="v">Vector as the divisor</param>
        public static void Vector3DivideByVector(global::System.Numerics.Vector3 dst, global::System.Numerics.Vector3 v)
        {
            var __arg0 = new IntPtr(&dst);
            var __arg1 = new IntPtr(&v);
            __Internal.Vector3DivideByVector(__arg0, __arg1);
        }

        /// <summary>Get the length of a 3D vector.</summary>
        /// <returns>v Vector to evaluate</returns>
        public static float Vector3Length(global::System.Numerics.Vector3 v)
        {
            var __arg0 = new IntPtr(&v);
            var ___ret = __Internal.Vector3Length(__arg0);
            return ___ret;
        }

        /// <summary>Get the squared length of a 3D vector.</summary>
        /// <returns>v Vector to evaluate</returns>
        public static float Vector3SquareLength(global::System.Numerics.Vector3 v)
        {
            var __arg0 = new IntPtr(&v);
            var ___ret = __Internal.Vector3SquareLength(__arg0);
            return ___ret;
        }

        /// <summary>Negate a 3D vector.</summary>
        /// <param name="dst">Vector to be negated</param>
        public static void Vector3Negate(global::System.Numerics.Vector3 dst)
        {
            var __arg0 = new IntPtr(&dst);
            __Internal.Vector3Negate(__arg0);
        }

        /// <summary>Get the dot product of 3D vectors.</summary>
        /// <param name="a">First vector</param>
        /// <param name="b">Second vector</param>
        /// <returns>The dot product of vectors</returns>
        public static float Vector3DotProduct(global::System.Numerics.Vector3 a, global::System.Numerics.Vector3 b)
        {
            var __arg0 = new IntPtr(&a);
            var __arg1 = new IntPtr(&b);
            var ___ret = __Internal.Vector3DotProduct(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Get cross product of 3D vectors.</summary>
        /// <param name="dst">Vector to receive the result.</param>
        /// <param name="a">First vector</param>
        /// <param name="b">Second vector</param>
        /// <returns>The dot product of vectors</returns>
        public static void Vector3CrossProduct(global::System.Numerics.Vector3 dst, global::System.Numerics.Vector3 a, global::System.Numerics.Vector3 b)
        {
            var __arg0 = new IntPtr(&dst);
            var __arg1 = new IntPtr(&a);
            var __arg2 = new IntPtr(&b);
            __Internal.Vector3CrossProduct(__arg0, __arg1, __arg2);
        }

        /// <summary>Normalize a 3D vector.</summary>
        /// <param name="v">Vector to normalize</param>
        public static void Vector3Normalize(global::System.Numerics.Vector3 v)
        {
            var __arg0 = new IntPtr(&v);
            __Internal.Vector3Normalize(__arg0);
        }

        /// <summary>Check for division by zero and normalize a 3D vector.</summary>
        /// <param name="v">Vector to normalize</param>
        public static void Vector3NormalizeSafe(global::System.Numerics.Vector3 v)
        {
            var __arg0 = new IntPtr(&v);
            __Internal.Vector3NormalizeSafe(__arg0);
        }

        /// <summary>Rotate a 3D vector by a quaternion.</summary>
        /// <param name="v">The vector to rotate by</param>
        /// <param name="q">Quaternion to use to rotate</param>
        public static void Vector3RotateByQuaternion(global::System.Numerics.Vector3 v, global::System.Numerics.Quaternion q)
        {
            var __arg0 = new IntPtr(&v);
            var __arg1 = new IntPtr(&q);
            __Internal.Vector3RotateByQuaternion(__arg0, __arg1);
        }

        /// <summary>Construct a 3x3 matrix from a 4x4 matrix.</summary>
        /// <param name="dst">Receives the output matrix</param>
        /// <param name="mat">The 4x4 matrix to use</param>
        public static void Matrix3FromMatrix4(global::AssimpNet.Unmanaged.Matrix3x3 dst, global::System.Numerics.Matrix4x4 mat)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            var __arg1 = new IntPtr(&mat);
            __Internal.Matrix3FromMatrix4(__arg0, __arg1);
        }

        /// <summary>Construct a 3x3 matrix from a quaternion.</summary>
        /// <param name="mat">Receives the output matrix</param>
        /// <param name="q">The quaternion matrix to use</param>
        public static void Matrix3FromQuaternion(global::AssimpNet.Unmanaged.Matrix3x3 mat, global::System.Numerics.Quaternion q)
        {
            var __arg0 = mat is null ? __IntPtr.Zero : mat.__Instance;
            var __arg1 = new IntPtr(&q);
            __Internal.Matrix3FromQuaternion(__arg0, __arg1);
        }

        /// <summary>Check if 3x3 matrices are equal.</summary>
        /// <param name="a">First matrix to compare</param>
        /// <param name="b">Second matrix to compare</param>
        /// <returns>1 if the matrices are equal</returns>
        /// <returns>0 if the matrices are not equal</returns>
        public static int Matrix3AreEqual(global::AssimpNet.Unmanaged.Matrix3x3 a, global::AssimpNet.Unmanaged.Matrix3x3 b)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            var __arg1 = b is null ? __IntPtr.Zero : b.__Instance;
            var ___ret = __Internal.Matrix3AreEqual(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Check if 3x3 matrices are equal.</summary>
        /// <param name="a">First matrix to compare</param>
        /// <param name="b">Second matrix to compare</param>
        /// <param name="epsilon">Epsilon</param>
        /// <returns>1 if the matrices are equal</returns>
        /// <returns>0 if the matrices are not equal</returns>
        public static int Matrix3AreEqualEpsilon(global::AssimpNet.Unmanaged.Matrix3x3 a, global::AssimpNet.Unmanaged.Matrix3x3 b, float epsilon)
        {
            var __arg0 = a is null ? __IntPtr.Zero : a.__Instance;
            var __arg1 = b is null ? __IntPtr.Zero : b.__Instance;
            var ___ret = __Internal.Matrix3AreEqualEpsilon(__arg0, __arg1, epsilon);
            return ___ret;
        }

        /// <summary>Invert a 3x3 matrix.</summary>
        /// <param name="mat">Matrix to invert</param>
        public static void Matrix3Inverse(global::AssimpNet.Unmanaged.Matrix3x3 mat)
        {
            var __arg0 = mat is null ? __IntPtr.Zero : mat.__Instance;
            __Internal.Matrix3Inverse(__arg0);
        }

        /// <summary>Get the determinant of a 3x3 matrix.</summary>
        /// <param name="mat">Matrix to get the determinant from</param>
        public static float Matrix3Determinant(global::AssimpNet.Unmanaged.Matrix3x3 mat)
        {
            var __arg0 = mat is null ? __IntPtr.Zero : mat.__Instance;
            var ___ret = __Internal.Matrix3Determinant(__arg0);
            return ___ret;
        }

        /// <summary>Get a 3x3 rotation matrix around the Z axis.</summary>
        /// <param name="mat">Receives the output matrix</param>
        /// <param name="angle">Rotation angle, in radians</param>
        public static void Matrix3RotationZ(global::AssimpNet.Unmanaged.Matrix3x3 mat, float angle)
        {
            var __arg0 = mat is null ? __IntPtr.Zero : mat.__Instance;
            __Internal.Matrix3RotationZ(__arg0, angle);
        }

        /// <summary>Returns a 3x3 rotation matrix for a rotation around an arbitrary axis.</summary>
        /// <param name="mat">Receives the output matrix</param>
        /// <param name="axis">Rotation axis, should be a normalized vector</param>
        /// <param name="angle">Rotation angle, in radians</param>
        public static void Matrix3FromRotationAroundAxis(global::AssimpNet.Unmanaged.Matrix3x3 mat, global::System.Numerics.Vector3 axis, float angle)
        {
            var __arg0 = mat is null ? __IntPtr.Zero : mat.__Instance;
            var __arg1 = new IntPtr(&axis);
            __Internal.Matrix3FromRotationAroundAxis(__arg0, __arg1, angle);
        }

        /// <summary>Get a 3x3 translation matrix.</summary>
        /// <param name="mat">Receives the output matrix</param>
        /// <param name="translation">The translation vector</param>
        public static void Matrix3Translation(global::AssimpNet.Unmanaged.Matrix3x3 mat, global::System.Numerics.Vector2 translation)
        {
            var __arg0 = mat is null ? __IntPtr.Zero : mat.__Instance;
            var __arg1 = new IntPtr(&translation);
            __Internal.Matrix3Translation(__arg0, __arg1);
        }

        /// <summary>Create a 3x3 matrix that rotates one vector to another vector.</summary>
        /// <param name="mat">Receives the output matrix</param>
        /// <param name="from">Vector to rotate from</param>
        /// <param name="to">Vector to rotate to</param>
        public static void Matrix3FromTo(global::AssimpNet.Unmanaged.Matrix3x3 mat, global::System.Numerics.Vector3 from, global::System.Numerics.Vector3 to)
        {
            var __arg0 = mat is null ? __IntPtr.Zero : mat.__Instance;
            var __arg1 = new IntPtr(&from);
            var __arg2 = new IntPtr(&to);
            __Internal.Matrix3FromTo(__arg0, __arg1, __arg2);
        }

        /// <summary>Construct a 4x4 matrix from a 3x3 matrix.</summary>
        /// <param name="dst">Receives the output matrix</param>
        /// <param name="mat">The 3x3 matrix to use</param>
        public static void Matrix4FromMatrix3(global::System.Numerics.Matrix4x4 dst, global::AssimpNet.Unmanaged.Matrix3x3 mat)
        {
            var __arg0 = new IntPtr(&dst);
            var __arg1 = mat is null ? __IntPtr.Zero : mat.__Instance;
            __Internal.Matrix4FromMatrix3(__arg0, __arg1);
        }

        /// <summary>Construct a 4x4 matrix from scaling, rotation and position.</summary>
        /// <param name="mat">Receives the output matrix.</param>
        /// <param name="scaling">The scaling for the x,y,z axes</param>
        /// <param name="rotation">The rotation as a hamilton quaternion</param>
        /// <param name="position">The position for the x,y,z axes</param>
        public static void Matrix4FromScalingQuaternionPosition(global::System.Numerics.Matrix4x4 mat, global::System.Numerics.Vector3 scaling, global::System.Numerics.Quaternion rotation, global::System.Numerics.Vector3 position)
        {
            var __arg0 = new IntPtr(&mat);
            var __arg1 = new IntPtr(&scaling);
            var __arg2 = new IntPtr(&rotation);
            var __arg3 = new IntPtr(&position);
            __Internal.Matrix4FromScalingQuaternionPosition(__arg0, __arg1, __arg2, __arg3);
        }

        /// <summary>Add 4x4 matrices.</summary>
        /// <param name="dst">First addend, receives result.</param>
        /// <param name="src">Matrix to be added to 'dst'.</param>
        public static void Matrix4Add(global::System.Numerics.Matrix4x4 dst, global::System.Numerics.Matrix4x4 src)
        {
            var __arg0 = new IntPtr(&dst);
            var __arg1 = new IntPtr(&src);
            __Internal.Matrix4Add(__arg0, __arg1);
        }

        /// <summary>Check if 4x4 matrices are equal.</summary>
        /// <param name="a">First matrix to compare</param>
        /// <param name="b">Second matrix to compare</param>
        /// <returns>1 if the matrices are equal</returns>
        /// <returns>0 if the matrices are not equal</returns>
        public static int Matrix4AreEqual(global::System.Numerics.Matrix4x4 a, global::System.Numerics.Matrix4x4 b)
        {
            var __arg0 = new IntPtr(&a);
            var __arg1 = new IntPtr(&b);
            var ___ret = __Internal.Matrix4AreEqual(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Check if 4x4 matrices are equal.</summary>
        /// <param name="a">First matrix to compare</param>
        /// <param name="b">Second matrix to compare</param>
        /// <param name="epsilon">Epsilon</param>
        /// <returns>1 if the matrices are equal</returns>
        /// <returns>0 if the matrices are not equal</returns>
        public static int Matrix4AreEqualEpsilon(global::System.Numerics.Matrix4x4 a, global::System.Numerics.Matrix4x4 b, float epsilon)
        {
            var __arg0 = new IntPtr(&a);
            var __arg1 = new IntPtr(&b);
            var ___ret = __Internal.Matrix4AreEqualEpsilon(__arg0, __arg1, epsilon);
            return ___ret;
        }

        /// <summary>Invert a 4x4 matrix.</summary>
        /// <param name="result">Matrix to invert</param>
        public static void Matrix4Inverse(global::System.Numerics.Matrix4x4 mat)
        {
            var __arg0 = new IntPtr(&mat);
            __Internal.Matrix4Inverse(__arg0);
        }

        /// <summary>Get the determinant of a 4x4 matrix.</summary>
        /// <param name="mat">Matrix to get the determinant from</param>
        /// <returns>The determinant of the matrix</returns>
        public static float Matrix4Determinant(global::System.Numerics.Matrix4x4 mat)
        {
            var __arg0 = new IntPtr(&mat);
            var ___ret = __Internal.Matrix4Determinant(__arg0);
            return ___ret;
        }

        /// <summary>Returns true of the matrix is the identity matrix.</summary>
        /// <param name="mat">Matrix to get the determinant from</param>
        /// <returns>1 ifis an identity matrix.</returns>
        /// <returns>0 ifis not an identity matrix.</returns>
        public static int Matrix4IsIdentity(global::System.Numerics.Matrix4x4 mat)
        {
            var __arg0 = new IntPtr(&mat);
            var ___ret = __Internal.Matrix4IsIdentity(__arg0);
            return ___ret;
        }

        /// <summary>
        /// <para>Decompose a transformation matrix into its scaling,</para>
        /// <para>rotational as euler angles, and translational components.</para>
        /// </summary>
        /// <param name="mat">Matrix to decompose</param>
        /// <param name="scaling">Receives the output scaling for the x,y,z axes</param>
        /// <param name="rotation">Receives the output rotation as a Euler angles</param>
        /// <param name="position">Receives the output position for the x,y,z axes</param>
        public static void Matrix4DecomposeIntoScalingEulerAnglesPosition(global::System.Numerics.Matrix4x4 mat, global::System.Numerics.Vector3 scaling, global::System.Numerics.Vector3 rotation, global::System.Numerics.Vector3 position)
        {
            var __arg0 = new IntPtr(&mat);
            var __arg1 = new IntPtr(&scaling);
            var __arg2 = new IntPtr(&rotation);
            var __arg3 = new IntPtr(&position);
            __Internal.Matrix4DecomposeIntoScalingEulerAnglesPosition(__arg0, __arg1, __arg2, __arg3);
        }

        /// <summary>
        /// <para>Decompose a transformation matrix into its scaling,</para>
        /// <para>rotational split into an axis and rotational angle,</para>
        /// <para>and it's translational components.</para>
        /// </summary>
        /// <param name="mat">Matrix to decompose</param>
        /// <param name="rotation">Receives the rotational component</param>
        /// <param name="axis">Receives the output rotation axis</param>
        /// <param name="angle">Receives the output rotation angle</param>
        /// <param name="position">Receives the output position for the x,y,z axes.</param>
        public static void Matrix4DecomposeIntoScalingAxisAnglePosition(global::System.Numerics.Matrix4x4 mat, global::System.Numerics.Vector3 scaling, global::System.Numerics.Vector3 axis, ref float angle, global::System.Numerics.Vector3 position)
        {
            var __arg0 = new IntPtr(&mat);
            var __arg1 = new IntPtr(&scaling);
            var __arg2 = new IntPtr(&axis);
            fixed (float* __angle3 = &angle)
            {
                var __arg3 = __angle3;
                var __arg4 = new IntPtr(&position);
                __Internal.Matrix4DecomposeIntoScalingAxisAnglePosition(__arg0, __arg1, __arg2, __arg3, __arg4);
            }
        }

        /// <summary>
        /// <para>Decompose a transformation matrix into its rotational and</para>
        /// <para>translational components.</para>
        /// </summary>
        /// <param name="mat">Matrix to decompose</param>
        /// <param name="rotation">Receives the rotational component</param>
        /// <param name="position">Receives the translational component.</param>
        public static void Matrix4DecomposeNoScaling(global::System.Numerics.Matrix4x4 mat, global::System.Numerics.Quaternion rotation, global::System.Numerics.Vector3 position)
        {
            var __arg0 = new IntPtr(&mat);
            var __arg1 = new IntPtr(&rotation);
            var __arg2 = new IntPtr(&position);
            __Internal.Matrix4DecomposeNoScaling(__arg0, __arg1, __arg2);
        }

        /// <summary>Creates a 4x4 matrix from a set of euler angles.</summary>
        /// <param name="mat">Receives the output matrix</param>
        /// <param name="x">Rotation angle for the x-axis, in radians</param>
        /// <param name="y">Rotation angle for the y-axis, in radians</param>
        /// <param name="z">Rotation angle for the z-axis, in radians</param>
        public static void Matrix4FromEulerAngles(global::System.Numerics.Matrix4x4 mat, float x, float y, float z)
        {
            var __arg0 = new IntPtr(&mat);
            __Internal.Matrix4FromEulerAngles(__arg0, x, y, z);
        }

        /// <summary>Get a 4x4 rotation matrix around the X axis.</summary>
        /// <param name="mat">Receives the output matrix</param>
        /// <param name="angle">Rotation angle, in radians</param>
        public static void Matrix4RotationX(global::System.Numerics.Matrix4x4 mat, float angle)
        {
            var __arg0 = new IntPtr(&mat);
            __Internal.Matrix4RotationX(__arg0, angle);
        }

        /// <summary>Get a 4x4 rotation matrix around the Y axis.</summary>
        /// <param name="mat">Receives the output matrix</param>
        /// <param name="angle">Rotation angle, in radians</param>
        public static void Matrix4RotationY(global::System.Numerics.Matrix4x4 mat, float angle)
        {
            var __arg0 = new IntPtr(&mat);
            __Internal.Matrix4RotationY(__arg0, angle);
        }

        /// <summary>Get a 4x4 rotation matrix around the Z axis.</summary>
        /// <param name="mat">Receives the output matrix</param>
        /// <param name="angle">Rotation angle, in radians</param>
        public static void Matrix4RotationZ(global::System.Numerics.Matrix4x4 mat, float angle)
        {
            var __arg0 = new IntPtr(&mat);
            __Internal.Matrix4RotationZ(__arg0, angle);
        }

        /// <summary>Returns a 4x4 rotation matrix for a rotation around an arbitrary axis.</summary>
        /// <param name="mat">Receives the output matrix</param>
        /// <param name="axis">Rotation axis, should be a normalized vector</param>
        /// <param name="angle">Rotation angle, in radians</param>
        public static void Matrix4FromRotationAroundAxis(global::System.Numerics.Matrix4x4 mat, global::System.Numerics.Vector3 axis, float angle)
        {
            var __arg0 = new IntPtr(&mat);
            var __arg1 = new IntPtr(&axis);
            __Internal.Matrix4FromRotationAroundAxis(__arg0, __arg1, angle);
        }

        /// <summary>Get a 4x4 translation matrix.</summary>
        /// <param name="mat">Receives the output matrix</param>
        /// <param name="translation">The translation vector</param>
        public static void Matrix4Translation(global::System.Numerics.Matrix4x4 mat, global::System.Numerics.Vector3 translation)
        {
            var __arg0 = new IntPtr(&mat);
            var __arg1 = new IntPtr(&translation);
            __Internal.Matrix4Translation(__arg0, __arg1);
        }

        /// <summary>Get a 4x4 scaling matrix.</summary>
        /// <param name="mat">Receives the output matrix</param>
        /// <param name="scaling">The scaling vector</param>
        public static void Matrix4Scaling(global::System.Numerics.Matrix4x4 mat, global::System.Numerics.Vector3 scaling)
        {
            var __arg0 = new IntPtr(&mat);
            var __arg1 = new IntPtr(&scaling);
            __Internal.Matrix4Scaling(__arg0, __arg1);
        }

        /// <summary>Create a 4x4 matrix that rotates one vector to another vector.</summary>
        /// <param name="mat">Receives the output matrix</param>
        /// <param name="from">Vector to rotate from</param>
        /// <param name="to">Vector to rotate to</param>
        public static void Matrix4FromTo(global::System.Numerics.Matrix4x4 mat, global::System.Numerics.Vector3 from, global::System.Numerics.Vector3 to)
        {
            var __arg0 = new IntPtr(&mat);
            var __arg1 = new IntPtr(&from);
            var __arg2 = new IntPtr(&to);
            __Internal.Matrix4FromTo(__arg0, __arg1, __arg2);
        }

        /// <summary>Create a Quaternion from euler angles.</summary>
        /// <param name="q">Receives the output quaternion</param>
        /// <param name="x">Rotation angle for the x-axis, in radians</param>
        /// <param name="y">Rotation angle for the y-axis, in radians</param>
        /// <param name="z">Rotation angle for the z-axis, in radians</param>
        public static void QuaternionFromEulerAngles(global::System.Numerics.Quaternion q, float x, float y, float z)
        {
            var __arg0 = new IntPtr(&q);
            __Internal.QuaternionFromEulerAngles(__arg0, x, y, z);
        }

        /// <summary>Create a Quaternion from an axis angle pair.</summary>
        /// <param name="q">Receives the output quaternion</param>
        /// <param name="axis">The orientation axis</param>
        /// <param name="angle">The rotation angle, in radians</param>
        public static void QuaternionFromAxisAngle(global::System.Numerics.Quaternion q, global::System.Numerics.Vector3 axis, float angle)
        {
            var __arg0 = new IntPtr(&q);
            var __arg1 = new IntPtr(&axis);
            __Internal.QuaternionFromAxisAngle(__arg0, __arg1, angle);
        }

        /// <summary>
        /// <para>Create a Quaternion from a normalized quaternion stored</para>
        /// <para>in a 3D vector.</para>
        /// </summary>
        /// <param name="q">Receives the output quaternion</param>
        /// <param name="normalized">The vector that stores the quaternion</param>
        public static void QuaternionFromNormalizedQuaternion(global::System.Numerics.Quaternion q, global::System.Numerics.Vector3 normalized)
        {
            var __arg0 = new IntPtr(&q);
            var __arg1 = new IntPtr(&normalized);
            __Internal.QuaternionFromNormalizedQuaternion(__arg0, __arg1);
        }

        /// <summary>Check if quaternions are equal.</summary>
        /// <param name="a">First quaternion to compare</param>
        /// <param name="b">Second quaternion to compare</param>
        /// <returns>1 if the quaternions are equal</returns>
        /// <returns>0 if the quaternions are not equal</returns>
        public static int QuaternionAreEqual(global::System.Numerics.Quaternion a, global::System.Numerics.Quaternion b)
        {
            var __arg0 = new IntPtr(&a);
            var __arg1 = new IntPtr(&b);
            var ___ret = __Internal.QuaternionAreEqual(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Check if quaternions are equal using epsilon.</summary>
        /// <param name="a">First quaternion to compare</param>
        /// <param name="b">Second quaternion to compare</param>
        /// <param name="epsilon">Epsilon</param>
        /// <returns>1 if the quaternions are equal</returns>
        /// <returns>0 if the quaternions are not equal</returns>
        public static int QuaternionAreEqualEpsilon(global::System.Numerics.Quaternion a, global::System.Numerics.Quaternion b, float epsilon)
        {
            var __arg0 = new IntPtr(&a);
            var __arg1 = new IntPtr(&b);
            var ___ret = __Internal.QuaternionAreEqualEpsilon(__arg0, __arg1, epsilon);
            return ___ret;
        }

        /// <summary>Normalize a quaternion.</summary>
        /// <param name="q">Quaternion to normalize</param>
        public static void QuaternionNormalize(global::System.Numerics.Quaternion q)
        {
            var __arg0 = new IntPtr(&q);
            __Internal.QuaternionNormalize(__arg0);
        }

        /// <summary>Compute quaternion conjugate.</summary>
        /// <param name="q">
        /// <para>Quaternion to compute conjugate,</para>
        /// <para>receives the output quaternion</para>
        /// </param>
        public static void QuaternionConjugate(global::System.Numerics.Quaternion q)
        {
            var __arg0 = new IntPtr(&q);
            __Internal.QuaternionConjugate(__arg0);
        }

        /// <summary>Multiply quaternions.</summary>
        /// <param name="dst">First quaternion, receives the output quaternion</param>
        /// <param name="q">Second quaternion</param>
        public static void QuaternionMultiply(global::System.Numerics.Quaternion dst, global::System.Numerics.Quaternion q)
        {
            var __arg0 = new IntPtr(&dst);
            var __arg1 = new IntPtr(&q);
            __Internal.QuaternionMultiply(__arg0, __arg1);
        }

        /// <summary>Performs a spherical interpolation between two quaternions.</summary>
        /// <param name="dst">Receives the quaternion resulting from the interpolation.</param>
        /// <param name="start">Quaternion when factor == 0</param>
        /// <param name="end">Quaternion when factor == 1</param>
        /// <param name="factor">Interpolation factor between 0 and 1</param>
        public static void QuaternionInterpolate(global::System.Numerics.Quaternion dst, global::System.Numerics.Quaternion start, global::System.Numerics.Quaternion end, float factor)
        {
            var __arg0 = new IntPtr(&dst);
            var __arg1 = new IntPtr(&start);
            var __arg2 = new IntPtr(&end);
            __Internal.QuaternionInterpolate(__arg0, __arg1, __arg2, factor);
        }
    }
}
