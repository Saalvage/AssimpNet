// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace AssimpNet.Unmanaged
{
    /// <summary>Enumerates the types of geometric primitives supported by Assimp.</summary>
    /// <remarks>
    /// <para>aiFace Face data structure</para>
    /// <para>aiProcess_SortByPType Per-primitive sorting of meshes</para>
    /// <para>aiProcess_Triangulate Automatic triangulation</para>
    /// <para>AI_CONFIG_PP_SBP_REMOVE Removal of specific primitive types.</para>
    /// </remarks>
    public enum PrimitiveType
    {
        /// <summary>A point primitive.</summary>
        /// <remarks>
        /// <para>This is just a single vertex in the virtual world,</para>
        /// <para>#aiFace contains just one index for such a primitive.</para>
        /// </remarks>
        PrimitiveTypePOINT = 1,
        /// <summary>A line primitive.</summary>
        /// <remarks>
        /// <para>This is a line defined through a start and an end position.</para>
        /// <para>#aiFace contains exactly two indices for such a primitive.</para>
        /// </remarks>
        PrimitiveTypeLINE = 2,
        /// <summary>A triangular primitive.</summary>
        /// <remarks>A triangle consists of three indices.</remarks>
        PrimitiveTypeTRIANGLE = 4,
        /// <summary>A higher-level polygon with more than 3 edges.</summary>
        /// <remarks>
        /// <para>A triangle is a polygon, but polygon in this context means</para>
        /// <para>&quot;all polygons that are not triangles&quot;. The &quot;Triangulate&quot;-Step</para>
        /// <para>is provided for your convenience, it splits all polygons in</para>
        /// <para>triangles (which are much easier to handle).</para>
        /// </remarks>
        PrimitiveTypePOLYGON = 8,
        /// <summary>A flag to determine whether this triangles only mesh is NGON encoded.</summary>
        /// <remarks>
        /// <para>NGON encoding is a special encoding that tells whether 2 or more consecutive triangles</para>
        /// <para>should be considered as a triangle fan. This is identified by looking at the first vertex index.</para>
        /// <para>2 consecutive triangles with the same 1st vertex index are part of the same</para>
        /// <para>NGON.</para>
        /// <para>At the moment, only quads (concave or convex) are supported, meaning that polygons are 'seen' as</para>
        /// <para>triangles, as usual after a triangulation pass.</para>
        /// <para>To get an NGON encoded mesh, please use the aiProcess_Triangulate post process.</para>
        /// <para>aiProcess_Triangulate</para>
        /// </remarks>
        PrimitiveTypeNGONEncodingFlag = 16,
        AiPrimitiveTypeForce32Bit = 2147483647
    }

    /// <summary>Enumerates the methods of mesh morphing supported by Assimp.</summary>
    public enum MorphingMethod
    {
        /// <summary>Morphing method to be determined</summary>
        MorphingMethodUNKNOWN = 0,
        /// <summary>Interpolation between morph targets</summary>
        MorphingMethodVERTEX_BLEND = 1,
        /// <summary>Normalized morphing between morph targets</summary>
        MorphingMethodMORPH_NORMALIZED = 2,
        /// <summary>Relative morphing between morph targets</summary>
        MorphingMethodMORPH_RELATIVE = 3,
        AiMorphingMethodForce32Bit = 2147483647
    }

    /// <summary>A single face in a mesh, referring to multiple vertices.</summary>
    /// <remarks>
    /// <para>If mNumIndices is 3, we call the face 'triangle', for mNumIndices &gt; 3</para>
    /// <para>it's called 'polygon' (hey, that's just a definition!).</para>
    /// <para></para>
    /// <para>aiMesh::mPrimitiveTypes can be queried to quickly examine which types of</para>
    /// <para>primitive are actually present in a mesh. The #aiProcess_SortByPType flag</para>
    /// <para>executes a special post-processing algorithm which splits meshes with</para>
    /// <para>*different* primitive types mixed up (e.g. lines and triangles) in several</para>
    /// <para>'clean' sub-meshes. Furthermore there is a configuration option (</para>
    /// <para>#AI_CONFIG_PP_SBP_REMOVE) to force #aiProcess_SortByPType to remove</para>
    /// <para>specific kinds of primitives from the imported scene, completely and forever.</para>
    /// <para>In many cases you'll probably want to set this setting to</para>
    /// <para>Together with the #aiProcess_Triangulate flag you can then be sure that</para>
    /// <para>#aiFace::mNumIndices is always 3.</para>
    /// <para>Take a look at the</para>
    /// </remarks>
    public unsafe partial class Face : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal uint mNumIndices;
            internal __IntPtr mIndices;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.Face> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.Face>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.Face managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.Face managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Face __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Face(native.ToPointer(), skipVTables);
        }

        internal static Face __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Face)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Face __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Face(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Face(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Face(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Number of indices defining this face.</para>
        /// <para>The maximum value for this member is #AI_MAX_FACE_INDICES.</para>
        /// </summary>
        public uint MNumIndices
        {
            get
            {
                return ((__Internal*)__Instance)->mNumIndices;
            }

            set
            {
                ((__Internal*)__Instance)->mNumIndices = value;
            }
        }

        /// <summary>Pointer to the indices array. Size of the array is given in numIndices.</summary>
        public uint* MIndices
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->mIndices;
            }

            set
            {
                ((__Internal*)__Instance)->mIndices = (__IntPtr) value;
            }
        }
    }

    /// <summary>A single influence of a bone on a vertex.</summary>
    public unsafe partial class VertexWeight : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal uint mVertexId;
            internal float mWeight;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.VertexWeight> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.VertexWeight>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.VertexWeight managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.VertexWeight managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VertexWeight __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VertexWeight(native.ToPointer(), skipVTables);
        }

        internal static VertexWeight __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VertexWeight)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VertexWeight __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VertexWeight(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VertexWeight(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VertexWeight(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Index of the vertex which is influenced by the bone.</summary>
        public uint MVertexId
        {
            get
            {
                return ((__Internal*)__Instance)->mVertexId;
            }

            set
            {
                ((__Internal*)__Instance)->mVertexId = value;
            }
        }

        /// <summary>
        /// <para>The strength of the influence in the range (0...1).</para>
        /// <para>The influence from all bones at one vertex amounts to 1.</para>
        /// </summary>
        public float MWeight
        {
            get
            {
                return ((__Internal*)__Instance)->mWeight;
            }

            set
            {
                ((__Internal*)__Instance)->mWeight = value;
            }
        }
    }

    /// <summary>A single bone of a mesh.</summary>
    /// <remarks>
    /// <para>A bone has a name by which it can be found in the frame hierarchy and by</para>
    /// <para>which it can be addressed by animations. In addition it has a number of</para>
    /// <para>influences on vertices, and a matrix relating the mesh position to the</para>
    /// <para>position of the bone at the time of binding.</para>
    /// </remarks>
    public unsafe partial class Bone : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1120)]
        public partial struct __Internal
        {
            internal global::AssimpNet.Unmanaged.String.__Internal mName;
            internal uint mNumWeights;
            internal __IntPtr mArmature;
            internal __IntPtr mNode;
            internal __IntPtr mWeights;
            internal global::System.Numerics.Matrix4x4 mOffsetMatrix;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.Bone> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.Bone>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.Bone managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.Bone managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Bone __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Bone(native.ToPointer(), skipVTables);
        }

        internal static Bone __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Bone)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Bone __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Bone(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Bone(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Bone(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The name of the bone.</summary>
        public global::AssimpNet.Unmanaged.String MName
        {
            get
            {
                return global::AssimpNet.Unmanaged.String.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->mName));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->mName = *(global::AssimpNet.Unmanaged.String.__Internal*) value.__Instance;
            }
        }

        /// <summary>
        /// <para>The number of vertices affected by this bone.</para>
        /// <para>The maximum value for this member is #AI_MAX_BONE_WEIGHTS.</para>
        /// </summary>
        public uint MNumWeights
        {
            get
            {
                return ((__Internal*)__Instance)->mNumWeights;
            }

            set
            {
                ((__Internal*)__Instance)->mNumWeights = value;
            }
        }

        /// <summary>
        /// <para>The bone armature node - used for skeleton conversion</para>
        /// <para>you must enable aiProcess_PopulateArmatureData to populate this</para>
        /// </summary>
        public global::AssimpNet.Unmanaged.Node MArmature
        {
            get
            {
                var __result0 = global::AssimpNet.Unmanaged.Node.__GetOrCreateInstance(((__Internal*)__Instance)->mArmature, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->mArmature = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>
        /// <para>The bone node in the scene - used for skeleton conversion</para>
        /// <para>you must enable aiProcess_PopulateArmatureData to populate this</para>
        /// </summary>
        public global::AssimpNet.Unmanaged.Node MNode
        {
            get
            {
                var __result0 = global::AssimpNet.Unmanaged.Node.__GetOrCreateInstance(((__Internal*)__Instance)->mNode, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->mNode = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>The influence weights of this bone, by vertex index.</summary>
        public global::AssimpNet.Unmanaged.VertexWeight MWeights
        {
            get
            {
                var __result0 = global::AssimpNet.Unmanaged.VertexWeight.__GetOrCreateInstance(((__Internal*)__Instance)->mWeights, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->mWeights = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>Matrix that transforms from mesh space to bone space in bind pose.</summary>
        /// <remarks>
        /// <para>This matrix describes the position of the mesh</para>
        /// <para>in the local space of this bone when the skeleton was bound.</para>
        /// <para>Thus it can be used directly to determine a desired vertex position,</para>
        /// <para>given the world-space transform of the bone when animated,</para>
        /// <para>and the position of the vertex in mesh space.</para>
        /// <para>It is sometimes called an inverse-bind matrix,</para>
        /// <para>or inverse bind pose matrix.</para>
        /// </remarks>
        public global::System.Numerics.Matrix4x4 MOffsetMatrix
        {
            get
            {
                return ((__Internal*)__Instance)->mOffsetMatrix;
            }

            set
            {
                ((__Internal*)__Instance)->mOffsetMatrix = value;
            }
        }
    }

    /// <summary>
    /// <para>An AnimMesh is an attachment to an #aiMesh stores per-vertex</para>
    /// <para>animations for a particular frame.</para>
    /// </summary>
    /// <remarks>
    /// <para>You may think of an #aiAnimMesh as a `patch` for the host mesh, which</para>
    /// <para>replaces only certain vertex data streams at a particular time.</para>
    /// <para>Each mesh stores n attached attached meshes (#aiMesh::mAnimMeshes).</para>
    /// <para>The actual relationship between the time line and anim meshes is</para>
    /// <para>established by #aiMeshAnim, which references singular mesh attachments</para>
    /// <para>by their ID and binds them to a time offset.</para>
    /// </remarks>
    public unsafe partial class AnimMesh : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1200)]
        public partial struct __Internal
        {
            internal global::AssimpNet.Unmanaged.String.__Internal mName;
            internal __IntPtr mVertices;
            internal __IntPtr mNormals;
            internal __IntPtr mTangents;
            internal __IntPtr mBitangents;
            internal fixed long mColors[8];
            internal fixed long mTextureCoords[8];
            internal uint mNumVertices;
            internal float mWeight;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.AnimMesh> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.AnimMesh>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.AnimMesh managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.AnimMesh managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static AnimMesh __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new AnimMesh(native.ToPointer(), skipVTables);
        }

        internal static AnimMesh __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (AnimMesh)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static AnimMesh __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new AnimMesh(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private AnimMesh(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected AnimMesh(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Weight of the AnimMesh.</summary>
        public float MWeight
        {
            get
            {
                return ((__Internal*)__Instance)->mWeight;
            }

            set
            {
                ((__Internal*)__Instance)->mWeight = value;
            }
        }
    }

    /// <summary>A mesh represents a geometry or model with a single material.</summary>
    /// <remarks>
    /// <para>It usually consists of a number of vertices and a series of primitives/faces</para>
    /// <para>referencing the vertices. In addition there might be a series of bones, each</para>
    /// <para>of them addressing a number of vertices with a certain weight. Vertex data</para>
    /// <para>is presented in channels with each channel containing a single per-vertex</para>
    /// <para>information such as a set of texture coordinates or a normal vector.</para>
    /// <para>If a data pointer is non-null, the corresponding data stream is present.</para>
    /// <para>From C++-programs you can also use the comfort functions Has*() to</para>
    /// <para>test for the presence of various data streams.</para>
    /// <para>A Mesh uses only a single material which is referenced by a material ID.</para>
    /// <para>The mPositions member is usually not optional. However, vertex positions</para>
    /// <para>*could* be missing if the #AI_SCENE_FLAGS_INCOMPLETE flag is set in</para>
    /// </remarks>
    public unsafe partial class Mesh : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1320)]
        public partial struct __Internal
        {
            internal uint mPrimitiveTypes;
            internal uint mNumVertices;
            internal uint mNumFaces;
            internal __IntPtr mVertices;
            internal __IntPtr mNormals;
            internal __IntPtr mTangents;
            internal __IntPtr mBitangents;
            internal fixed long mColors[8];
            internal fixed long mTextureCoords[8];
            internal fixed uint mNumUVComponents[8];
            internal __IntPtr mFaces;
            internal uint mNumBones;
            internal __IntPtr mBones;
            internal uint mMaterialIndex;
            internal global::AssimpNet.Unmanaged.String.__Internal mName;
            internal uint mNumAnimMeshes;
            internal __IntPtr mAnimMeshes;
            internal global::AssimpNet.Unmanaged.MorphingMethod mMethod;
            internal global::AssimpNet.Unmanaged.AABB.__Internal mAABB;
            internal __IntPtr mTextureCoordsNames;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.Mesh> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.Mesh>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.Mesh managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.Mesh managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Mesh __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Mesh(native.ToPointer(), skipVTables);
        }

        internal static Mesh __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Mesh)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Mesh __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Mesh(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Mesh(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Mesh(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Vertex UV stream names. Pointer to array of size AI_MAX_NUMBER_OF_TEXTURECOORDS</summary>
        public global::AssimpNet.Unmanaged.String MTextureCoordsNames
        {
            get
            {
                var __result0 = global::AssimpNet.Unmanaged.String.__GetOrCreateInstance(((__Internal*)__Instance)->mTextureCoordsNames, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->mTextureCoordsNames = new __IntPtr(&__value);
            }
        }
    }

    /// <summary>A skeleton bone represents a single bone is a skeleton structure.</summary>
    /// <remarks>
    /// <para>Skeleton-Animations can be represented via a skeleton struct, which describes</para>
    /// <para>a hierarchical tree assembled from skeleton bones. A bone is linked to a mesh.</para>
    /// <para>The bone knows its parent bone. If there is no parent bone the parent id is</para>
    /// <para>marked with -1.</para>
    /// <para>The skeleton-bone stores a pointer to its used armature. If there is no</para>
    /// <para>armature this value if set to nullptr.</para>
    /// <para>A skeleton bone stores its offset-matrix, which is the absolute transformation</para>
    /// <para>for the bone. The bone stores the locale transformation to its parent as well.</para>
    /// <para>You can compute the offset matrix by multiplying the hierarchy like:</para>
    /// <para>Tree: s1 -&gt; s2 -&gt; s3</para>
    /// <para>Offset-Matrix s3 = locale-s3 * locale-s2 * locale-s1</para>
    /// </remarks>
    public unsafe partial class SkeletonBone : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 176)]
        public partial struct __Internal
        {
            internal int mParent;
            internal __IntPtr mArmature;
            internal __IntPtr mNode;
            internal uint mNumnWeights;
            internal __IntPtr mMeshId;
            internal __IntPtr mWeights;
            internal global::System.Numerics.Matrix4x4 mOffsetMatrix;
            internal global::System.Numerics.Matrix4x4 mLocalMatrix;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.SkeletonBone> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.SkeletonBone>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.SkeletonBone managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.SkeletonBone managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SkeletonBone __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new SkeletonBone(native.ToPointer(), skipVTables);
        }

        internal static SkeletonBone __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SkeletonBone)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SkeletonBone __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SkeletonBone(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SkeletonBone(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SkeletonBone(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The parent bone index, is -1 one if this bone represents the root bone.</summary>
        public int MParent
        {
            get
            {
                return ((__Internal*)__Instance)->mParent;
            }

            set
            {
                ((__Internal*)__Instance)->mParent = value;
            }
        }

        /// <summary>
        /// <para>The bone armature node - used for skeleton conversion</para>
        /// <para>you must enable aiProcess_PopulateArmatureData to populate this</para>
        /// </summary>
        public global::AssimpNet.Unmanaged.Node MArmature
        {
            get
            {
                var __result0 = global::AssimpNet.Unmanaged.Node.__GetOrCreateInstance(((__Internal*)__Instance)->mArmature, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->mArmature = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>
        /// <para>The bone node in the scene - used for skeleton conversion</para>
        /// <para>you must enable aiProcess_PopulateArmatureData to populate this</para>
        /// </summary>
        public global::AssimpNet.Unmanaged.Node MNode
        {
            get
            {
                var __result0 = global::AssimpNet.Unmanaged.Node.__GetOrCreateInstance(((__Internal*)__Instance)->mNode, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->mNode = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>The number of weights</summary>
        public uint MNumnWeights
        {
            get
            {
                return ((__Internal*)__Instance)->mNumnWeights;
            }

            set
            {
                ((__Internal*)__Instance)->mNumnWeights = value;
            }
        }

        /// <summary>The mesh index, which will get influenced by the weight.</summary>
        public global::AssimpNet.Unmanaged.Mesh MMeshId
        {
            get
            {
                var __result0 = global::AssimpNet.Unmanaged.Mesh.__GetOrCreateInstance(((__Internal*)__Instance)->mMeshId, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->mMeshId = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>The influence weights of this bone, by vertex index.</summary>
        public global::AssimpNet.Unmanaged.VertexWeight MWeights
        {
            get
            {
                var __result0 = global::AssimpNet.Unmanaged.VertexWeight.__GetOrCreateInstance(((__Internal*)__Instance)->mWeights, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->mWeights = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>Matrix that transforms from bone space to mesh space in bind pose.</summary>
        /// <remarks>
        /// <para>This matrix describes the position of the mesh</para>
        /// <para>in the local space of this bone when the skeleton was bound.</para>
        /// <para>Thus it can be used directly to determine a desired vertex position,</para>
        /// <para>given the world-space transform of the bone when animated,</para>
        /// <para>and the position of the vertex in mesh space.</para>
        /// <para>It is sometimes called an inverse-bind matrix,</para>
        /// <para>or inverse bind pose matrix.</para>
        /// </remarks>
        public global::System.Numerics.Matrix4x4 MOffsetMatrix
        {
            get
            {
                return ((__Internal*)__Instance)->mOffsetMatrix;
            }

            set
            {
                ((__Internal*)__Instance)->mOffsetMatrix = value;
            }
        }

        /// <summary>Matrix that transforms the locale bone in bind pose.</summary>
        public global::System.Numerics.Matrix4x4 MLocalMatrix
        {
            get
            {
                return ((__Internal*)__Instance)->mLocalMatrix;
            }

            set
            {
                ((__Internal*)__Instance)->mLocalMatrix = value;
            }
        }
    }

    /// <summary>A skeleton represents the bone hierarchy of an animation.</summary>
    /// <remarks>
    /// <para>Skeleton animations can be described as a tree of bones:</para>
    /// <para>root</para>
    /// <para>|</para>
    /// <para>node1</para>
    /// <para>/\</para>
    /// <para>node3  node4</para>
    /// <para>If you want to calculate the transformation of node three you need to compute the</para>
    /// <para>transformation hierarchy for the transformation chain of node3:</para>
    /// <para>root-&gt;node1-&gt;node3</para>
    /// <para>Each node is represented as a skeleton instance.</para>
    /// </remarks>
    public unsafe partial class Skeleton : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1040)]
        public partial struct __Internal
        {
            internal global::AssimpNet.Unmanaged.String.__Internal mName;
            internal uint mNumBones;
            internal __IntPtr mBones;
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.Skeleton> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::AssimpNet.Unmanaged.Skeleton>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::AssimpNet.Unmanaged.Skeleton managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::AssimpNet.Unmanaged.Skeleton managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Skeleton __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Skeleton(native.ToPointer(), skipVTables);
        }

        internal static Skeleton __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Skeleton)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Skeleton __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Skeleton(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Skeleton(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Skeleton(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The name of the skeleton instance.</summary>
        public global::AssimpNet.Unmanaged.String MName
        {
            get
            {
                return global::AssimpNet.Unmanaged.String.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->mName));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->mName = *(global::AssimpNet.Unmanaged.String.__Internal*) value.__Instance;
            }
        }

        /// <summary>The number of bones in the skeleton.</summary>
        public uint MNumBones
        {
            get
            {
                return ((__Internal*)__Instance)->mNumBones;
            }

            set
            {
                ((__Internal*)__Instance)->mNumBones = value;
            }
        }

        /// <summary>The bone instance in the skeleton.</summary>
        public global::AssimpNet.Unmanaged.SkeletonBone MBones
        {
            get
            {
                var __result0 = global::AssimpNet.Unmanaged.SkeletonBone.__GetOrCreateInstance(((__Internal*)__Instance)->mBones, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->mBones = new __IntPtr(&__value);
            }
        }
    }
}
